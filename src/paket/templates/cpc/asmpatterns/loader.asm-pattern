    org {LOADER_START_ADDRESS}

; scr_set_mode:        equ #bc0e

; ------------------------------------------------
; main program:

start:
    call clear_screen
    call set_mode_0
    di
    ld hl, empty_interrupt_callback
    ld (#0039),hl

{LOADER_LOADING_CODE}

IF {LOADER_SECOND_BLOCK} == 1
    ld hl, copy_block2_and_start_game
    ld de, #f000
    ld bc, copy_block2_and_start_game_end - copy_block2_and_start_game
    ldir
    jp #f000
ELSE
    jp {START_ADDRESS}  ; run the game!!!
ENDIF


; ------------------------------------------------
empty_interrupt_callback:
    ei
    ret


; ------------------------------------------------
set_mode_0:
    ld bc, #7f00   ; Gate array port
    ld a, #8c      ; Mode and ROM selection + set mode 0
    out (c),a     ; Send it
    ret


; ------------------------------------------------
set_mode_1:
    ld bc, #7f00   ; Gate array port
    ld a, #8d      ; Mode and ROM selection + set screen 1
    out (c), a     ; Send it
    ret


; ------------------------------------------------
; Clears the video memory to all 0s.
clear_screen:
    ld hl, #c000    ; Clear the screen
    ld bc, #4000    
    ld (hl), 0
    ld e, l
    ld d, h
    inc de
    ldir
    ret


use_rle:
    db 0
rle_count_buffer:
    db 0


; ------------------------------------------------
; Changes the color palette for MODE 0
; hl : palette pointer (16 colors)
set_palette_mode_0:
    ld ixl, 16
    xor a
palette_loop:
    push af
        ; set pen "a" to hardware color "palette[a]":
        ld bc, #7f00   ; Gate Array port
        out (c), a     ; Send pen number
        ld a, (hl)     ; Pen colour (and Gate Array function)
        out (c), a     ; Send it
    pop af
    inc hl
    inc a
    cp ixl
    jr nz, palette_loop
    ret


; ------------------------------------------------
; Changes the color palette for MODE 1
; hl : palette pointer (4 colors)
set_palette_mode_1:
    ld ixl, 4
    xor a
    jr palette_loop


;-----------------------------------------------
; waits a given number of "halts"
; bc - number of halts
wait_bc_halts:
    halt
    dec bc
    ld a, b
    or c
    jr nz, wait_bc_halts
    ret


;-----------------------------------------------
; Reads a keyboard row
; code from: http://www.cpcwiki.eu/index.php/Programming:Keyboard_scanning
; input:
; - a: keyboard line
; read_keyboard_line:
;     di
;     ld d, 0
;     ld bc, #f782  ; PPI port A out / C out 
;     out (c), c 
;     ld bc, #f40e  ; Select Ay reg 14 on ppi port A 
;     out (c), c 
;     ld bc, #f6c0  ; This value is an AY index (R14) 
;     out (c), c 
;     out (c), d  ; Validate!! out (c),0
;     ld bc, #f792  ; PPI port A in / C out 
;     out (c), c 
;     dec b 
;     out (c), a  ; Send KbdLine on reg 14 AY through ppi port A
;     ld b, #f4  ; Read ppi port A 
;     in a, (c)  ; e.g. AY R14 (AY port A) 
;     ld bc, #f782  ; PPI port A out / C out 
;     out (c), c 
;     dec b  ; Reset PPI Write 
;     out (c), d  ; out (c),0
;     ei
;     ret


;-----------------------------------------------
; Waits until the player presses space
; wait_for_space:
;     ld a, #45
;     call read_keyboard_line
;     bit 7, a
;     ret z
;     halt
;     jr wait_for_space


{LOADER_COLOR_PALETTES}
    

; ------------------------------------------------
; This is a modified version of the loader used by TOPO SOFT
; Source code taken from:
; Input:
; - IX = start
; - DE = length (D must not be #ff)
; - A = sync byte expected
;
; Interrupts must be disabled
;
; Output:
; - carry clear - load ok
; - carry set, zero set - time up
; - carry set, zero reset - if esc pressed

topoload:
    inc     d                    ;; reset the zero flag (D cannot hold #ff)
    ex      af,af'                ;; A register holds sync byte. 
    dec     d                    ;; restore D

    exx
                                ;; we need B' to be so we can write to gate-array i/o port for colour change when loading

        ld      bc,#7f00+#10        ;; Gate-Array + border
        out     (c),c                ;; select pen index to change while loading (#10 is border)
        ld c,#54                    ;; set to black
        out (c),c
    exx

    ld      bc,#f40e            ;; select AY register 14 (for reading keyboard)
    out     (c),c

    ld      bc,#f600+#c0+#10    ;; "AY write register" and enable tape motor
    out     (c),c

    ld      c,#10                ;; "AY inactive" and enable tape motor (register is latched into AY)
    out     (c),c

    ld      bc,#f792            ;; set PPI port A to read (so we can read keyboard data)
    out     (c),c                ;; this will also write 0 to port C and port A on CPC.

    ld      bc,#f600+#40+#10+#8    ;; tape motor enable, "AY read register", select keyboard row 8
                                ;; (keys on this row: z, caps lock, a, tab, q, esc, 2, 1)
                                ;; we are only interested in ESC
    out     (c),c

    ;; make an initial read of cassette input
    ld      a,#f5            ;; PPI port B
    in      a,(#00)            ;; read port (tape read etc)
    and     #80                ;; isolate tape read data

    ld      c,a
    cp      a                ;; set the zero flag
l8107: 
    ret nz                     ;; returns if esc key is pressed (was RET NZ)
l8108: 
    call    l817b
    jr      nc,l8107

    ;; the wait is meant to be almost one second
    ld      hl,#415
l8110: 
    djnz    l8110
    dec     hl
    ld      a,h
    or      l
    jr      nz,l8110
    ;; continue if only two edges are found within this allowed time period
    call    l8177
    jr      nc,l8107

    ;; only accept leader signal
l811c: 
    ld      b,#9c
    call    l8177
    jr      nc,l8107
    ld      a,#b9
    cp      b
    jr      nc,l8108
    inc     h
    jr      nz,l811c

    ;; on/off parts of sync pulse
l812b: 
    ld      b,#c9
    call    l817b
    jr      nc,l8107
    ld      a,b
    cp      #d1
    jr      nc,l812b
l8137: 
    call    l817b
    ret     nc

    ld      h,#00            ;; parity matching byte (checksum)
    ld      b,#b0            ;; timing constant for flag byte and data
    jr      l815d

l8145: 
    ex      af,af'            ;; fetch the flags
    jr      nz,l814d        ;; jump if we are handling first byte
    ;; L = data byte read from cassette
    ;; store to RAM
;    ld      (ix),l
;    inc     ix                ;; increase destination
;    jr      l8159

    push af
        ld a,(use_rle)
        or a
        jr nz,write_to_mem_rle

        ld (ix),l             ;; no RLE, just write to RAM
        inc ix
        jr write_to_mem_done

write_to_mem_rle:
        dec a
        jr z,write_to_mem_rle_state1
        dec a
        jr z,write_to_mem_rle_state2
        jr write_to_mem_rle_state3

        ; initial state, before finding any meta character
write_to_mem_rle_state1:
        ld a,l
        cp #ff
        jr z,write_to_mem_rle_meta_found    
        ld (ix),l             ;; no meta, just write to RAM
        inc ix
        jr write_to_mem_done

write_to_mem_rle_meta_found:
        ld a,2
        ld (use_rle),a
        jr write_to_mem_done

        ; We have found the meta character, and just need to read the amount to copy
write_to_mem_rle_state2:
        ld a,3
        ld (use_rle),a
        ld a,l
        ld (rle_count_buffer),a
        jr write_to_mem_done

        ; We know the amount to copy, here we just loop copying, and reset the state
write_to_mem_rle_state3:
        push bc
            ld a,(rle_count_buffer)
            ld b,a
            ld a,l
write_to_mem_rle_state3_loop:
            ld (ix),a
            inc ix
            djnz write_to_mem_rle_state3_loop
        pop bc
        ld a,1
        ld (use_rle),a

write_to_mem_done:
    pop af
    jr      l8159


l814d: 
    rr      c                ;; keep carry in safe place
                            ;; NOTE: Bit 7 is cassette read previous state
                            ;; We need to do a right shift so that cassette read moves into bit 6,
                            ;; our stored carry then goes into bit 7
    xor     l                ;; check sync byte is as we expect
    ret     nz

    ld      a,c                ;; restore carry flag now
    rla                     ;; bit 7 goes into carry restoring it, bit 6 goes back to bit 7 to restore tape input value
    ld      c,a
    inc     de            ;; increase counter to compensate for it's decrease

l8159: 
    dec     de            ;; decrease counter
    ex      af,af'        ;; save the flags

    ld      b,#b2        ;; timing constant
l815d: 
    ld      l,#01        ;; marker bit (defines number of bits to read, and finally becomes value read)
l815f: 
    call    l8177
    ret     nc

    ld      a,#c3        ;; compare the length against approx 2,400T states, resetting the carry flag for a '0' and setting it for a '1'
    cp      b
    rl      l            ;; include the new bit in the register
    ld      b,#b0        ;; set timing constant for next bit
    jr      nc,l815f

    ;; L = data byte read
    ;; combine with checksum
    ld      a,h
    xor     l
    ld      h,a

    ;; DE = count
    ld      a,d
    or      e
    jr      nz,l8145

    exx
        ld c,#54                        ;; make border black
        out (c),c
    exx

    ld      bc,#f782                ;; set PPI port A for output
    out     (c),c
    ld      bc,#f600                ;; tape motor off, "AY inactive"
    out     (c),c

    ;; H = checksum byte
    ;; H = 0 means checksum ok
    ld      a,h
    cp      #01
    ;; return with carry flag set if the result is good
    ;; carry clear otherwise
    ret     


    ;;------------------------------------------------------------
l8177: 
    call l817b            ;; in effect call ld-edge-1 twice returning in between if there is an error
    ret nc

    ;; wait 358T states before entering sampling loop
l817b: 
    ld a,#16            ;; [2]
l817d: 
    dec a                ;; [1]
    jr nz,l817d        ;; ([3]+[1])*#15+[2]

    and a
l8181: 
    inc b                ;; count each pass
    ret z                ;; return carry reset and zero set if time up.

    ;; read keyboard
    ld a,#f4            ;; PPI port A 
    in a,(00h)            ;; read port and read keyboard through AY register 14
    and #04                ;; isolate state of bit 2 (ESC key)
                            ;; bit will be 0 if key is pressed
    xor #04                ;; has key been pressed? 
    ret nz                ;; quit (carry reset, zero reset)

    ld a,#f5            ;; PPI port B
    in a,(#00)            ;; read port (tape read etc)
    xor c
    and #80                ;; isolate tape read
    jr z,l8181
    ld a,c                ;; effectively toggle bit 7 of C
    cpl                     ;; which is the tape read state we want to see next
    ld c,a

    exx                 ;; swap to alternative register set so that we can change colour
                        ;; this sets colour and gives us the multi colour border
        ld a,r                ;; get R register
        and #1f                ;; ensure it is in range of colour value
        or #40                ;; bit 7 = 0, bit 6 = 1
        out (c),a            ;; write colour value
        nop                    ;; this is to ensure the number of cycles is the same
                            ;; compared to the replaced instructions
                            ;; (timings from toposoft loader)
    exx     
    scf     
    ret     


;;------------------------------------------------------------------------
IF {LOADER_SECOND_BLOCK} == 1
copy_block2_and_start_game:
    ld hl, copy_block2_and_start_game_end
    ld de, {LOADER_START_ADDRESS}
    ld bc, {BINARY2_TAPE_SIZE}
    ldir
    jp {START_ADDRESS}  ; run the game!!!
copy_block2_and_start_game_end:
ENDIF
