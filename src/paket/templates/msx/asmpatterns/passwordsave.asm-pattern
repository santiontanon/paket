PASSWORD_SAVEGAME_SIZE_IN_BITS: equ {PASSWORD_SAVEGAME_SIZE_IN_BITS}
PASSWORD_SAVEGAME_SIZE_IN_BYTES: equ {PASSWORD_SAVEGAME_SIZE_IN_BYTES}
PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS: equ {PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS}
PASSWORD_BITS_PER_CHARACTER: equ {PASSWORD_BITS_PER_CHARACTER}

password_bits_buffer: equ savegame_data_buffer + savegame_data_size
password_char_buffer: equ password_bits_buffer + PASSWORD_SAVEGAME_SIZE_IN_BYTES
password_render_synth_buffer: equ password_char_buffer + PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS
password_checksums: equ password_render_synth_buffer + 2
password_cursor: equ password_checksums + 2  ; #fe: accept, #ff: cancel, otherwise, character within the password


;-----------------------------------------------
password_xor_mask:
    db #5a, #13, #f0, #46

IF N_GAME_STATE_VARIABLES > 0
; For each variable, two bytes: minimum value, and bits to save.
password_variable_data:
    db {PASSWORD_VARIABLE_DATA}
ENDIF

password_character_table:
    db {PASSWORD_CHARACTER_TABLE}
password_character_table_end:

PASSWORD_CHARACTER_TABLE_SIZE: equ password_character_table_end - password_character_table


;-----------------------------------------------
; Read data from a password input by the player.
; Input:
; - ix: data to write the decoded data from the password
; Output:
; - c: success
; - nc: failure
paket_read_from_media:
    push ix
        call clear_pattern_attribute_tables_and_sprites

        ; Show author-defined messages:
        ld c, {PASSWORD_LOAD_TEXT_BANK}
        ld a, {PASSWORD_LOAD_TEXT_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
        ld hl, current_action_text_buffer
        ld de, CHRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + REGULAR_TEXT_FIRST_ROW*32*8
        ld iyl, COLOR_DARK_BLUE*16
        call draw_multi_line_sentence

        ld c, {PASSWORD_LOAD_ACCEPT_TEXT_BANK}
        ld a, {PASSWORD_LOAD_ACCEPT_TEXT_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
        ld hl, current_action_text_buffer
        ld de, CHRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 2)*32*8
        ld iyl, COLOR_DARK_BLUE*16
        call draw_sentence

        ld c, {PASSWORD_LOAD_CANCEL_TEXT_BANK}
        ld a, {PASSWORD_LOAD_CANCEL_TEXT_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
        ld hl, current_action_text_buffer
        ld de, CHRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 3)*32*8
        ld iyl, COLOR_DARK_BLUE*16
        call draw_sentence

        ld c, {PASSWORD_LOAD_INCORRECT_TEXT_BANK}
        ld a, {PASSWORD_LOAD_INCORRECT_TEXT_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
        ld hl, current_action_text_buffer
        ld de, CHRTBL2 + 8*(6 + (32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 6)*32*8
        ld iyl, 0  ; make it hidden, we will make it appear later
        call draw_sentence

        ; Get the characters:
        ld c, {PASSWORD_CHARACTERS_BANK}
        ld a, {PASSWORD_CHARACTERS_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank

        ; initialize an empty password:
        ld hl, password_char_buffer
        ld bc, PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS
        ld a, #ff
        call clear_memory_to_a

        xor a
        ld (password_cursor), a

        ; password entering loop:
        call password_getcharacter_nonwaiting_reset
    pop ix
paket_read_from_media_loop:
    push ix
        call wait_for_next_frame
        call password_render
        call password_highlight_options
        call password_getcharacter_nonwaiting
        cp #1c  ; right
        call z, password_move_right
        cp #1d  ; left
        call z, password_move_left
        cp #1e  ; up
        call z, password_move_up
        cp #1f  ; down
        call z, password_move_down
    pop ix
    cp ' '
    jr z, password_space_pressed
    or a
    push ix
        call nz, password_enter_character
    pop ix
    jr paket_read_from_media_loop

paket_read_from_media_loop_cancel:
    call clear_text_area
    ; clear text area attributes too:
    xor a
    ld hl, CLRTBL2 + 32 * 8
    ld bc, 32 * 8 * N_REGULAR_TEXT_ROWS
    call FILVRM

    call upload_gui_tiles_to_VDP
    call draw_gui
    call draw_room
    xor a  ; error
    ret


password_move_right:
    push af
        ld hl, password_cursor
        ld a, (hl)
        cp PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 1
        jr z, password_move_right_end
        inc (hl)
    pop af
    ret
password_move_right_end:
password_move_up_from_cancel:
password_move_down_from_last_line:
        ld (hl), #fe  ; go to 'accept'
    pop af
    ret


password_move_left:
    push af
        ld hl, password_cursor
        ld a, (hl)
        cp #fe
        jr z, password_move_left_into_password
        dec (hl)
    pop af
    ret
password_move_left_into_password:
password_move_up_from_accept:
        ld (hl), PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 1  ; last character
    pop af
    ret


password_move_up:
    push af
        ld hl, password_cursor
        ld a, (hl)
        cp #ff
        jr z, password_move_up_from_cancel
        cp #fe
        jr z, password_move_up_from_accept
        cp 16
        jr c, password_move_up_from_first_line
        sub a, 16
        ld (hl), a
    pop af
    ret
password_move_up_from_first_line:
password_move_down_from_accept:
        ld (hl), #ff  ; go to 'cancel'
    pop af
    ret


password_move_down:
    push af
        ld hl, password_cursor
        ld a, (hl)
        cp #ff
        jr z, password_move_down_from_cancel
        cp #fe
        jr z, password_move_down_from_accept
IF PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS <= 16
        jr password_move_down_from_last_line
ELSE
        cp a, PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 16
        jr nc, password_move_down_from_last_line
        add a, 16
        ld (hl), a
ENDIF
    pop af
    ret
password_move_down_from_cancel:
        ld (hl), 0
    pop af
    ret


password_space_pressed:
    ld a, (password_cursor)
    cp #ff  ; cancel
    jr z, paket_read_from_media_loop_cancel
    cp #fe  ; accept
    jp nz, paket_read_from_media_loop
    ; User pressed "accept", try to restore the game with this password!

    push ix
        call password_encode_characters_into_bits
        call password_entered_checksum_check
    pop ix
    jr nz, password_checksum_check_failed

    ; restore game!
    call password_decode_bits_into_savegame

    call clear_text_area
    ; clear text area attributes too:
    xor a
    ld hl, CLRTBL2 + 32 * 8
    ld bc, 32 * 8 * N_REGULAR_TEXT_ROWS
    call FILVRM

    scf  ; success
    ret


password_checksum_check_failed:
    ; show error message:
    ld hl, CLRTBL2 + 8*(6 + (32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 6)*32*8
    ld bc, 8*(SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE - 6)
    ld a, COLOR_RED * 16
    call FILVRM

    call wait_for_space

    ; hide error message:
    ld hl, CLRTBL2 + 8*(6 + (32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 6)*32*8
    ld bc, 8*(SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE - 6)
    xor a
    call FILVRM

    call password_getcharacter_nonwaiting_reset  ; to make sure we don't read again the space press
    jp paket_read_from_media_loop


password_enter_character:
    ld c, a
    ld a, (password_cursor)
    cp #fe
    ret nc
    ld a, c

    ; convert the key press into a character:
    ld hl, password_character_table
    ld b, PASSWORD_CHARACTER_TABLE_SIZE
    ld c, 0
password_enter_character_loop:
    cp (hl)
    jr z, password_enter_character_found
    inc hl
    inc c
    djnz password_enter_character_loop
    ret
password_enter_character_found:
    ld a, (password_cursor)
    ld hl, password_char_buffer
    ADD_HL_A
    ld (hl), c
    jp password_move_right


password_highlight_options:
    ld a, (password_cursor)
    push af
        cp #fe
        ld a, COLOR_DARK_BLUE * 16
        jr nz, password_highlight_options_no_accept
        ld a, COLOR_WHITE * 16
password_highlight_options_no_accept:
        ld hl, CLRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 2)*32*8
        ld bc, 8 * 16
        call FILVRM
    pop af
    cp #ff
    ld a, COLOR_DARK_BLUE * 16
    jr nz, password_highlight_options_no_cancel
    ld a, COLOR_WHITE * 16
password_highlight_options_no_cancel:
    ld hl, CLRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + (REGULAR_TEXT_FIRST_ROW + 2 + 4 + 3)*32*8
    ld bc, 8 * 16
    jp FILVRM


; ------------------------------------------------
; Converts save game data to a passwords and shows it to the player.
; Input:
; - ix: data buffer where the savegame information is stored.
; Output:
; - c: success
; - nc: failure
paket_write_to_media:
    push ix
        call clear_pattern_attribute_tables_and_sprites

        ; Show author-defined message:
        ld c, {PASSWORD_SAVE_TEXT_BANK}
        ld a, {PASSWORD_SAVE_TEXT_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
        ld hl, current_action_text_buffer
        ld de, CHRTBL2 + 8*((32-SCREEN_WIDTH_IN_TILES*MSX_TILES_PER_ENGINE_TILE)/2) + REGULAR_TEXT_FIRST_ROW*32*8
        ld iyl, COLOR_DARK_BLUE*16
        call draw_multi_line_sentence

        ; Get the characters:
        ld c, {PASSWORD_CHARACTERS_BANK}
        ld a, {PASSWORD_CHARACTERS_IDX}
        ld de, current_action_text_buffer
        call get_text_from_bank
    pop ix

    ; Compute password:
    call password_encode_savegame_into_bits  ; generates the bits to save in "password_bits_buffer" and "password_checksums".
    call password_encode_bits_into_characters  ; generates the password characters in "password_char_buffer"

    ; Show password:
    call password_render

    call wait_for_space

    call upload_gui_tiles_to_VDP
    call draw_gui
    call draw_room
    scf
    ret


;-----------------------------------------------
; Input:
; - ix: ptr to savegame buffer
password_encode_savegame_into_bits:
    push ix
    exx
        pop hl
    exx
    ; encode:
    ; init the password to all 0s: (remove once the encode code is done)
    ld hl, password_bits_buffer
    ld bc, PASSWORD_SAVEGAME_SIZE_IN_BYTES
    call clear_memory
    
    ld ix, password_bits_buffer
    ld iyl, 8
    ld iyh, 0    

    ; save current room:
    exx
        ld a, (hl)
        inc hl
    exx
    ld c, a
    ld b, {PASSWORD_ROOM_N_BITS}
    call password_write_n_bits

    ; save inventory:
    ld b, INVENTORY_SIZE
password_encode_savegame_into_bits_inventory_loop:
    push bc
        exx
            ld a, (hl)
            inc hl
        exx
        ld c, a
        ld b, {PASSWORD_INVENTORY_ITEM_N_BITS}
        call password_write_n_bits
    pop bc
    djnz password_encode_savegame_into_bits_inventory_loop

IF N_GAME_STATE_VARIABLES > 0
    ; save gamestate variables:
    ld b, N_GAME_STATE_VARIABLES
    ld de, password_variable_data
password_encode_savegame_into_bits_variables_loop:
    push bc
        exx
            ld a, (hl)
            inc hl
        exx
        ld c, a
        ld a, (de)  ; minimum variable value
        ld b, a
        ld a, c
        sub b
        ld c, a   ; c = variable - minimum variable value
        inc de
        ld a, (de)  ; bits per variable
        ld b, a
        inc de
        call password_write_n_bits
    pop bc
    djnz password_encode_savegame_into_bits_variables_loop
ENDIF

    ; save player x, y:
    exx
        ld a, (hl)
        inc hl
    exx
    ld c, a
    ld b, {PASSWORD_PLAYER_X_N_BITS}
    call password_write_n_bits
    exx
        ld a, (hl)
        inc hl
    exx
    ld c, a
    ld b, {PASSWORD_PLAYER_Y_N_BITS}
    call password_write_n_bits

    ; current song/tempo:
    ; save player x, y:
    exx
        ld a, (hl)
        inc hl
    exx
    ld c, a
    ld b, {PASSWORD_SONG_N_BITS}
    call password_write_n_bits
    exx
        ld a, (hl)
        inc hl
    exx
    ld c, a
    ld b, {PASSWORD_TEMPO_N_BITS}
    call password_write_n_bits

    call password_flush_bit_write_buffer
    call password_apply_xor_mask
    call password_compute_checksum
    ld (password_checksums), hl
    ret


;-----------------------------------------------
; Input:
; - ix: ptr to savegame buffer
password_decode_bits_into_savegame:
    push ix
        call password_apply_xor_mask
    pop hl
    ld ix, password_bits_buffer
    ld iyl, 0
    ld iyh, 0

    ; current room:
    ld b, {PASSWORD_ROOM_N_BITS}
    call password_get_n_bits
    ld (hl), a
    inc hl

    ; inventory:
    ld b, INVENTORY_SIZE
password_decode_bits_into_savegame_inventory_loop:
    push bc
        ld b, {PASSWORD_INVENTORY_ITEM_N_BITS}
        call password_get_n_bits
        ld (hl), a
        inc hl
    pop bc
    djnz password_decode_bits_into_savegame_inventory_loop

    ; game state variables:
IF N_GAME_STATE_VARIABLES > 0
    ; save gamestate variables:
    ld b, N_GAME_STATE_VARIABLES
    ld de, password_variable_data
password_decode_bits_into_savegame_variables_loop:
    push bc
        ld a, (de)  ; minimum variable value
        push af
            inc de
            ld a, (de)  ; bits per variable
            inc de
            ld b, a
            call password_get_n_bits
            ld c, a
        pop af
        add a, c
        ld (hl), a
        inc hl
    pop bc
    djnz password_decode_bits_into_savegame_variables_loop
ENDIF

    ; player x, y:
    ld b, {PASSWORD_PLAYER_X_N_BITS}
    call password_get_n_bits
    ld (hl), a
    inc hl
    ld b, {PASSWORD_PLAYER_Y_N_BITS}
    call password_get_n_bits
    ld (hl), a
    inc hl

    ; current song/tempo:
    ld b, {PASSWORD_SONG_N_BITS}
    call password_get_n_bits
    ld (hl), a
    inc hl
    ld b, {PASSWORD_TEMPO_N_BITS}
    call password_get_n_bits
    ld (hl), a
    ret


;-----------------------------------------------
password_flush_bit_write_buffer:
    ld a, iyl
    cp 8
    ret z
    ld c, 0
    ld b, a
    ; jr password_write_n_bits


;-----------------------------------------------
; input:
; - c: value
; - b: n bits to write from 'c'
; - ix: ptr to next byte in the bits array
; - iyl: how many bits can we still write to iyh
; - iyh: current byte we are writing to the bits array (with all the bits written so far)
password_write_n_bits:
    ; shift 'a' '8 - b' bits to the left:
    ld a, b
password_write_n_bits_preshift_loop:
    cp 8
    jr z, password_write_n_bits_preshift_done
    rl c
    inc a
    jr password_write_n_bits_preshift_loop
password_write_n_bits_preshift_done:
    ; Here the bits to be written are the most-significant bits of 'c':
    rl c
    ld a, iyh
    adc a, a
    ld iyh, a
    dec iyl
    jr nz, password_write_n_bits_no_whole_byte_yet
    ld (ix), a
    inc ix
    ld iyl, 8
    ld iyh, 0
password_write_n_bits_no_whole_byte_yet:    
    djnz password_write_n_bits_preshift_done
    ret


;-----------------------------------------------
; input:
; - b: n bits to read
; - ix: ptr to next byte in the bits array
; - iyl: current bit in the bits array
; - iyh: last byte read from the bits array (potentially shifted)
; output:
; - a: bits read
password_get_n_bits:
    ld c, 0
password_get_n_bits_loop:
    ld a, iyl
    or a
    jr nz, password_get_n_bits_loop_byte_read
    ld a, (ix)
    ld iyh, a
    ld iyl, 8
    inc ix
password_get_n_bits_loop_byte_read:
    ld a, iyh
    add a, a
    ld iyh, a
    ld a, c
    adc a, a
    ld c, a
    dec iyl
    djnz password_get_n_bits_loop
    ld a, c
    ret


;-----------------------------------------------
password_encode_bits_into_characters:
    ; Put each PASSWORD_BITS_PER_CHARACTER bits into a separate byte:
    ld de, PASSWORD_SAVEGAME_SIZE_IN_BITS
    ld hl, password_char_buffer + 1
    ld ix, password_bits_buffer
    ld iyl, 0
password_encode_bits_into_characters_loop:
    ld a, d
    or a
    jr nz, password_encode_bits_into_characters_loop_not_last
    ld a, e
    or a
    jr z, password_encode_bits_into_characters_loop_done
    cp PASSWORD_BITS_PER_CHARACTER
    jr nc, password_encode_bits_into_characters_loop_not_last
    ld b, e
    jr password_encode_bits_into_characters_loop_get_bits
password_encode_bits_into_characters_loop_not_last:
    ld b, PASSWORD_BITS_PER_CHARACTER
password_encode_bits_into_characters_loop_get_bits:
    push hl
        ; de -= b:
        ld a, b
        neg
        ld h, #ff
        ld l, a  ; now hl = -b
        add hl, de  ; hl = de - b
        ex de, hl
    pop hl
    call password_get_n_bits
    ; add checksum1:
    ld c, a
    ld a, (password_checksums + 1)
    add a, c
    and {CHECKSUM2_AND_MASK}
    ld (hl), a
    inc hl
    jr password_encode_bits_into_characters_loop
password_encode_bits_into_characters_loop_done:
    ; First and last character are the checksums:
    ld hl, (password_checksums)
    ld a, h
    ld (password_char_buffer), a
    ld a, l
    ld (password_char_buffer + PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 1), a
    ret


;-----------------------------------------------
; fills 'password_bits_buffer' from 'password_char_buffer' (ignoring the checksum)
password_encode_characters_into_bits:
    ld a, (password_char_buffer)  ; checksum1 (we need to subtract this from every character)
    ld e, a
    ld hl, password_char_buffer + 1
    ld ix, password_bits_buffer
    ld iyl, 8
    ld iyh, 0    
    ld b, PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 2
password_encode_characters_into_bits_loop:
    push bc
        ld a, (hl)
        sub e
        and {CHECKSUM2_AND_MASK}
        ld c, a
        ld b, PASSWORD_BITS_PER_CHARACTER
        call password_write_n_bits
        inc hl
    pop bc
    djnz password_encode_characters_into_bits_loop
    call password_flush_bit_write_buffer
    ret


;-----------------------------------------------
password_apply_xor_mask:
    ld hl, password_bits_buffer
    ld ix, password_xor_mask
    ld b, PASSWORD_SAVEGAME_SIZE_IN_BYTES
password_apply_xor_mask_loop:
    ld a, (hl)
    xor (ix)
    ld (hl), a
    inc hl
    dec b
    ret z
    ld a, (hl)
    xor (ix + 1)
    ld (hl), a
    inc hl
    dec b
    ret z
    ld a, (hl)
    xor (ix + 2)
    ld (hl), a
    inc hl
    dec b
    ret z
    ld a, (hl)
    xor (ix + 3)
    ld (hl), a
    inc hl
    djnz password_apply_xor_mask_loop
    ret


;-----------------------------------------------
; compute checksums:
; output:
; - h: checksum1: number of 1s.
; - l: checksum2: sum of each group of PASSWORD_BITS_PER_CHARACTER bits.
password_compute_checksum:
    ld hl, 0  ; h: checksum1, l: checksum2
    ld ix, password_bits_buffer
    ld iyl, 0
    ld de, PASSWORD_SAVEGAME_SIZE_IN_BITS
password_compute_checksum_loop:
    ld a, d
    or a
    jr nz, password_compute_checksum_loop_not_last
    ld a, e
    or a
    jr z, password_compute_checksum_loop_done
    cp PASSWORD_BITS_PER_CHARACTER
    jr nc, password_compute_checksum_loop_not_last
    ld b, e
    jr password_compute_checksum_loop_get_bits
password_compute_checksum_loop_not_last:
    ld b, PASSWORD_BITS_PER_CHARACTER
password_compute_checksum_loop_get_bits:
    push hl
        ; de -= b:
        ld a, b
        neg
        ld h, #ff
        ld l, a  ; now hl = -b
        add hl, de  ; hl = de - b
        ex de, hl
    pop hl
    call password_get_n_bits
    ; update checksum 2:
    ld c, a
    add a, l
    ld l, a
    ; update checksum 1: (count number of 1s)
    ld a, c
    ld b, 8
password_compute_checksum_loop_checksum1_loop:
    add a, a
    jr nc, password_compute_checksum_loop_checksum1_loop_continue
    inc h
password_compute_checksum_loop_checksum1_loop_continue:
    djnz password_compute_checksum_loop_checksum1_loop
    
    jr password_compute_checksum_loop
password_compute_checksum_loop_done:
    ld a, l
    and {CHECKSUM2_AND_MASK}
    ld l, a
    ret


;-----------------------------------------------
; output:
; - z: checksum ok
; - nz: checksum fail
password_entered_checksum_check:
    call password_compute_checksum
    ld a, (password_char_buffer)
    cp h
    ret nz
    ld a, (password_char_buffer + PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS - 1)
    cp l
    ret


;-----------------------------------------------
password_render:
    ld a, 1
    ld (password_render_synth_buffer), a

    ld b, PASSWORD_SAVEGAME_SIZE_IN_CHARACTERS
    ld c, 0
    ld hl, password_char_buffer
    ld de, CHRTBL2 + 8*6 + (REGULAR_TEXT_FIRST_ROW + 3)*32*8

password_render_loop:
    ld a, (hl)
    push hl
        cp #ff  ; check if we have not yet entered a character
        jr nz, password_render_loop_proper_character
        ; empty cell:
        call password_render_empty_cell
        ex de, hl
        jr password_render_loop_character_drawn
password_render_loop_proper_character:
        ld hl, current_action_text_buffer + 1
        ADD_HL_A
        ld a, (hl)
        ld (password_render_synth_buffer + 1), a
        push de
        push bc
            ld hl, password_render_synth_buffer
            ld a, (password_cursor)
            cp c
            ld iyl, COLOR_WHITE*16
            jr nz, password_render_loop_proper_character_continue
            ld iyl, COLOR_WHITE*16 + COLOR_LIGHT_GREEN
password_render_loop_proper_character_continue:
            ld bc, 8
            call draw_sentence_bc_width
        pop bc
        pop hl
password_render_loop_character_drawn:
        inc c
        ld a, c
        and #0f ; each 16 characters, next line
        jr z, password_render_loop_next_line
        ; next character position:
        ld de, 8
        add hl, de
        and #03  ; each 4 characters skip an extra one
        jr nz, password_render_loop_continue2
password_render_loop_continue:
        add hl, de
password_render_loop_continue2:
        ex de, hl
    pop hl
    inc hl  ; next character
    djnz password_render_loop

    ret

password_render_loop_next_line:
        ld de, 8*(32 + 1 - (16 + 3))
        jr password_render_loop_continue


;-----------------------------------------------
; - de: ptr to video memory
password_render_empty_cell:
    push de
    push bc
        ld a, (password_cursor)
        cp c
        ld a, COLOR_DARK_RED
        jr nz, password_render_empty_cell_continue
        ld a, COLOR_LIGHT_GREEN  ; cursor position, we need to highlight it
password_render_empty_cell_continue:
        push af
            push de
                ld h, d
                ld l, e
                ld bc, 7
                ld a, 1
                call FILVRM
            pop hl
            ld de, CLRTBL2 - CHRTBL2
            add hl, de
            ld bc, 7
        pop af
        call FILVRM
    pop bc
    pop de
    ret


;-----------------------------------------------
; Adapted from the CHGET routine here: https://sourceforge.net/p/cbios/cbios/ci/master/tree/src/main.asm#l289
; It returns 0 if no key is ready to be read
password_getcharacter_nonwaiting:
    ld hl, (GETPNT)
    ld de, (PUTPNT)
    call DCOMPR
    jr z, password_getcharacter_nonwaiting_invalidkey
    ; there is a character ready to be read:
    ld a, (hl)
    push af
        inc hl
        ld a, l
        cp #00ff & (KEYBUF + 40)
        jr nz, password_getcharacter_nonwaiting_nowrap
        ld hl, KEYBUF
password_getcharacter_nonwaiting_nowrap:
        ld (GETPNT), hl
    pop af
    ret
password_getcharacter_nonwaiting_invalidkey:
    xor a
    ret

password_getcharacter_nonwaiting_reset:
    di
    ld hl, (PUTPNT)
    ld (GETPNT), hl
    ei
    ret
