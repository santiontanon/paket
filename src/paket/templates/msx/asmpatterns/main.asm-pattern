    include "constants-autogenerated.asm"
IS_MEGAROM:  equ 0
PKT_IS_MULTIPAGE: equ IS_MEGAROM

    org {START_ADDRESS}

;-----------------------------------------------
    db "AB"     ; ROM signature
    dw execute  ; start address
    db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
;-----------------------------------------------


;-----------------------------------------------
; Code that gets executed when the game starts
execute:
    di
    ; init the stack:
    ld sp, #f380
    ; reset some interrupts to make sure it runs in some MSX computers 
    ; with disk controllers installed in some interrupt handlers
    ld a, #c9
    ld (HKEY), a
    ld (TIMI), a
    ei

    ; set it to be a 32KB ROM:
    call SETPAGES32K

    ; Silence, init keyboard, and clear config:
    xor a
    ld (CLIKSW), a
    ; Change background colors:
    ld (BAKCLR), a
    ld (BDRCLR), a
    call CHGCLR
   
    ; SCREEN 2:
    ld a, 2      
    call CHGMOD

    ; 16x16 sprites:
    ld bc, #e201  ; write #e2 in VDP register #01 (activate sprites, 
                 ; generate interrupts, 16x16 sprites with no magnification)
    call WRTVDP

    call clear_name_table

{INIT_SOUND_CODE}

    call setup_custom_interrupt

    jp {GAME_START_LABEL}


; ------------------------------------------------
initialize_game_state_variables:
{GAME_STATE_VARIABLE_INITIALIZATION}
    ret

{GAME_STATE_VARIABLE_LABELS}


; ------------------------------------------------
; Additional source files
    include "auxiliar.asm"
    {DECOMPRESSOR_INCLUDE}
    {SOUND_PLAYER_INCLUDE}
    include "interrupt.asm"
    include "input.asm"
    include "gfx-autogenerated.asm"
    include "text.asm"
    include "rooms.asm"
    include "objects.asm"
    include "game.asm"
    include "gui.asm"
    include "player.asm"
    include "rules-autogenerated.asm"
    include "dialogue.asm"
IF USE_PATH_FINDING != 0
    include "pathfinding.asm"
ENDIF
IF {SCRIPT_SAVE_GAME_USED} + {SCRIPT_LOAD_GAME_USED} != 0
    include "passwordsave-autogenerated.asm"
ENDIF
    {ADDITIONAL_ASSEMBLER_FILES}
end_of_code:


; ------------------------------------------------
; Binary data

{TEXT_BANKS}

{TILE_BANKS}

IF {N_TILE_BANKSETS} > 1
{TILE_BANKSETS}
ENDIF

{OBJECT_TYPE_BANKS}

{ROOM_BANK_PTRS_DATA}

{ROOM_BANKS_DATA}

{DIALOGUE_DATA}

{GUI_DATA}

item_sprite_data:
    incbin "data/items.{COMPRESSOR_EXTENSION}"
item_text_data:
{ITEM_TEXT_DATA}

pointers_compressed:
    incbin "data/pointers.{COMPRESSOR_EXTENSION}"

font:
    incbin "data/font.bin"

; global rules:
global_rules_item:
    incbin "data/itemrules.bin"
global_rules_on_room_load:
    incbin "data/onroomloadrules.bin"
global_rules_on_room_start:
    incbin "data/onroomstartrules.bin"

{SCRIPTS}

{SFX_DATA}

{SONG_DATA}

IF {SCRIPT_DRAW_CUTSCENE_IMAGE_USED} == 1
{CUTSCENE_IMAGE_PTRS_DATA}
{CUTSCENE_IMAGES_DATA}
ENDIF

action_name_ptrs:
    dw action_name_look
    dw action_name_pickup
    dw action_name_use
    dw action_name_talk
    dw action_name_exit

action_name_look:
    db {ACTION_NAME_LOOK}
action_name_pickup:
    db {ACTION_NAME_PICKUP}
action_name_use:
    db {ACTION_NAME_USE}
action_name_talk:
    db {ACTION_NAME_TALK}
action_name_exit:
    db {ACTION_NAME_EXIT}
action_with:
    db {ACTION_WITH}
action_dotdotdot:
    db {ACTION_DOTDOTDOT}
dialogue_pause_text:
    db {DIALOGUE_PAUSE_TEXT}

additional_assembler_functions:
{ADDITIONAL_ASSEMBLER_FUNCTIONS}


endOfROM:
    ds (((($ - 1) / #4000) + 1) * #4000 - $) - 512


; ------------------------------------------------
; RAM:
    org #c000
start_of_RAM:

MUSIC_current_song:                 ds virtual 1  ; 0 if no song, song offset + 1 if a song is playing
MUSIC_muted:                        ds virtual 1  ; This is different from "MUSIC_tempo == 0", since we need to track when a music should be playing, but we just have it muted.

IF MUSIC_TYPE_TSV == 1
; sound variables:
MUSIC_tempo:                        ds virtual 1
beginning_of_sound_variables_except_tempo:
MUSIC_tempo_counter:                ds virtual 1
MUSIC_instruments:                  ds virtual 3
MUSIC_channel3_instrument_buffer:   ds virtual 1  ; this stores the instrument of channel 3, which is special, since SFX might overwrite it
MUSIC_start_pointer:                ds virtual 2  
SFX_pointer:                        ds virtual 2
MUSIC_pointer:                      ds virtual 2
MUSIC_repeat_stack_ptr:             ds virtual 2  ; 15
MUSIC_repeat_stack:                 ds virtual 4*3  ; 27
MUSIC_instrument_envelope_ptr:      ds virtual 3*2  ; 33
SFX_priority:                       ds virtual 1  ; the SFX from the game have more priority than those triggered by music
; MUSIC_transpose:                    ds virtual 1
MUSIC_time_step_required:           ds virtual 1  ; 39
load_new_song_request:              ds virtual 2
IF MUSIC_USE_INSTRUMENT_SPEED == 1
MUSIC_instrument_speed:             ds virtual 3
MUSIC_instrument_speed_counter:     ds virtual 3
ENDIF
IF MUSIC_USE_SET_VOLUME == 1
MUSIC_volumes:                      ds virtual 3
ENDIF
end_of_sound_variables:

music_buffer:                       ds virtual {MUSIC_BUFFER_SIZE}
ENDIF

IF MUSIC_TYPE_WYZ == 1
    include "wyzproplay46c-ram.asm"

; SFX player variables (PSG registers that overwrite those set by the wyz player):
; - registers 2, 3, 6, 7 and 9
SFX_player_registers:   ds virtual 5
SFX_player_active: ds virtual 1
SFX_player_pointer: ds virtual 2
ENDIF

; General variables:
vsyncs_since_last_frame:            ds virtual 1
game_cycle:                         ds virtual 1
last_script_in_this_rule:           ds virtual 1
IF PLAYER_SCALING = 1
; not implemented in MSX
; player_zoom_draw_function_ptr:      ds virtual 2
ENDIF

IF SCRIPT_CUSTOM_ASSEMBLER_ROOM_DRAW_USED == 1
custom_assembler_room_draw:         ds virtual 2
custom_assembler_room_draw_fullredraw_only: ds virtual 1
ENDIF

IF SCRIPT_CUSTOM_ASSEMBLER_ON_UPDATE_USED == 1
custom_assembler_on_update:         ds virtual 2
ENDIF

small_general_buffer:
text_draw_buffer:                   ds virtual SCREEN_WIDTH_IN_TILES*2*8
general_buffer:                     ds virtual GENERAL_BUFFER_SIZE

data_to_zero_on_game_start_start:
keyboard_line_state:                ds virtual 4
keyboard_line_state_prev:           ds virtual 4
keyboard_line_clicks:               ds virtual 4

pointer_y:                          ds virtual 1
pointer_x:                          ds virtual 1
current_pointer_type:               ds virtual 1
pointer_move_time:                  ds virtual 1    ; for how long have we been moving the pointer, to increase speed

currently_selected_verb:            ds virtual 1    ; 0 is no verb, 1: examine, 2: pickup, 3: use, 4: talk
currently_selected_item_to_use:     ds virtual 1    ; 0 is no item, and then it starts in 1
current_action_text_buffer:         ds virtual {ACTION_TEXT_BUFFER_SIZE}
current_action_text_id:             ds virtual 1    ; a code to indicate whether we need to redraw the current text or not, bits:
                                                    ; XXYYYYYY: XX = 00 nothing, 01 verb, 10 inventory item, 11 object
                                                    ;           YY = ID of the thing selected

; current action the player is executing:
player_in_room:                     ds virtual 1    ; 0 if the player is not in the room, 1 if it is
player_object_ptr:                  ds virtual 2
player_current_action:              ds virtual 1    ; 0: no action, 1: walking
player_current_action_parameters:   ds virtual 2    ; for walking: target coordinates
player_current_action_target_object:    ds virtual 2  ; pointer to the target object, if any

; current event (used for rule matching):
current_event:                      ds virtual 4    ; event can be at most 3 btes + the terminating 0
redraw_whole_room_signal:           ds virtual 1    ; if this is != 0, we will redraw the whole room 
                                                    ; (for when an object is picked up, for example)
redraw_inventory_signal:            ds virtual 1
exit_upon_clicking_outside:         ds virtual 1    ; if this is != 0, the game knows that there is a rule that will take you to
                                                    ; another room if clicking outside of the game area. So, it is used to display
                                                    ; the "exit" pointer graphic

; persistent state:
data_for_savegame_start:
current_room:                       ds virtual 1
inventory_ids:                      ds virtual INVENTORY_SIZE
game_state_variables:               ds virtual N_GAME_STATE_VARIABLES
data_for_savegame_end:

IF PLAYER_SCALING = 1
; not implemented in MSX
; player_scale:                       ds virtual 1  ; #ff 112.5%, 0: 100% scale, 1: 87.5%, 2: 75%
ENDIF

data_to_zero_on_game_start_end:

savegame_data_buffer: equ general_buffer + 5
savegame_data_size: equ (data_for_savegame_end - data_for_savegame_start) + 4

IF MAX_OBJECT_TYPES_PER_ROOM*5 > savegame_data_size + 5
    text_decompression_buffer: equ general_buffer + MAX_OBJECT_TYPES_PER_ROOM*5
ELSE
    text_decompression_buffer: equ general_buffer + savegame_data_size + 5
ENDIF


; pointer sprites attributes buffer:
pointer_sprites_attributes:         ds virtual 4*2
player_sprites_attributes:          ds virtual 4*N_PLAYER_SPRITES
player_sprites_patterns:            ds virtual 32*N_PLAYER_SPRITES

; inventory data:
inventory_name_ptrs:                ds virtual INVENTORY_SIZE * 2
inventory_gfx:                      ds virtual INVENTORY_SIZE * 4
inventory_name_buffer:              ds virtual INVENTORY_NAME_BUFFER_SIZE
inventory_name_next_ptr:            ds virtual 2

; Buffers to store the graphics/objects of the current room:

; This buffer contains first all the object types, and then all the tiles of the
; current room:
tiles_and_object_type_data_buffer:            ds virtual ROOM_TILES_OBJECT_COMBINED_BUFFER_SIZE
; This contains the pointer within 'tiles_and_object_type_data_buffer' where
; the tile data starts:
tile_buffer_ptr:    ds virtual 2
room_object_name_buffer:            ds virtual ROOM_OBJECTS_NAME_BUFFER_SIZE
room_buffer:                        ds virtual ROOM_BUFFER_SIZE
room_specific_on_load_or_start_rules_buffer: ds virtual ROOM_SPECIFIC_ON_LOAD_RULES_BUFFER_SIZE

last_room_object_ptr:               ds virtual 2    ; contains a pointer to the last object in the room 
                                                    ; (this is just so we don't need to calculate it every frame)

    ds (((($-1)/#08)+1)*#08-$)  ; make this buffer 8-aligned
room_column_draw_buffer:            ds virtual 16 * 16 * 2  ; enough to fit a column, and to allow switching from attributes to patterns with just inc/dec h
IF MAX_ROOM_HEIGHT > 16
    ERROR "The code assumes MAX_ROOM_HEIGHT <= 16!"
ENDIF
dirty_column_buffer:                ds virtual MAX_ROOM_WIDTH + 1  ; "+1" since some times we overwrite one extra byte, so, just to be safe.

; scrolled_at_least_once:             ds virtual 1    ; whether we have scrolled at least once since the last time 
;                                                     ; "clear_text_area_for_scroll" was called 
text_scrolling_next_row:            ds virtual 1    ; The row at which the new line will be drawn. If this is N_REGULAR_TEXT_ROWS+1, then 
                                                    ; the text will scroll up first

IF DOUBLE_CLICK_ON_EXIT == 1
double_click:                       ds virtual 1
time_since_last_space_click:        ds virtual 1
ENDIF

; Overloaded variables used at different points during execution:
player_mask_x:                                      ; used while drawing the player
player_mask_y:                      equ player_mask_x + 1
next_tile_idx:                                      ; used during room tile loading
object_type_data_buffer_next_ptr:   ds virtual 2    ; used during room object loading
currently_decompressed_tile_bank:                   ; used during room tile loading
object_type_loaded_cache_next_ptr:  ds virtual 2    ; used during room object loading
room_object_name_buffer_next_ptr:   ds virtual 2    ; used during room object loading

; dialogue state:
dialogue_goto_state:                ds virtual 1
dialogue_n_options:                 ds virtual 1
dialogue_option_target_states:      ds virtual MAX_DIALOGUE_OPTIONS
dialogue_option_text_ids:           ds virtual 2 * MAX_DIALOGUE_OPTIONS
dialogue_option_extended_text_ids:  ds virtual 2*MAX_DIALOGUE_OPTIONS

IF USE_PATH_FINDING != 0
; path finding path: initialized to #ff. Each element is a 2 byte (x,y) 
; point. (#ff, #ff) indicates the end of the path. The final destination is not
; part of the path. Once there are no more points in this path, the player will
; go in a straight line towards the target.
path_finding_path_buffer:           ds virtual PATH_FINDING_MAX_LENGTH * 2
path_finding_path_ptr:              ds virtual 2
collision_column_offsets:           ds virtual MAX_ROOM_COLLISION_WIDTH * 2
path_finding_stack:                 ds virtual 2
ENDIF
IF USE_PATH_FINDING == 2
path_finding_invoked:               ds virtual 1
ENDIF

IF {SCRIPT_LOAD_GAME_USED} == 1
; We will synthesize here a script to teleport the player to the correct room
; after loading the data:
executeRuleScript_load_game_load_room_script:  ds virtual 8
ENDIF


end_of_RAM:
