/*
 * author: Santiago Ontañón Villar (Brain Games)
 */
package paket.platforms;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import paket.compiler.PAKETCompiler;
import paket.compiler.PAKETConfig;
import paket.compiler.SpaceAllocator;
import paket.compiler.optimizers.PAKETOptimizer;
import paket.pak.PAKGame;
import paket.pak.PAKObjectType;
import paket.util.Pair;

/**
 *
 * @author santi
 */
public class MSXMegaROM extends MSX {

    int max_pages = 16;  // We will limit the ROM to 256KB
    List<SpaceAllocator.Space> pageSpaces = null;

    public MSXMegaROM(int a_tileWidth, HashMap<String, String> a_variables, PAKETConfig a_config) {
        super(a_tileWidth, a_variables, a_config);
        
        supportedSaveGameModes.clear();
        supportedSaveGameModes.add("password");
        defaultSaveGameMode = "password";        
    }

    // returns the size of the largest bank:
    @Override
    public int generateObjectTypeBanks(String outputFolder, List<PAKObjectType> objectTypes, PAKGame game,
            PAKETOptimizer optimizerState) throws Exception {
        Pair<Integer, Integer> tmp = generateObjectTypeBanksInternal(outputFolder, objectTypes, game, optimizerState);
        int n_banks = tmp.m_a;
        int largest_size = tmp.m_b;

        String objectBanksCode = "objectTypeBanksPointers:\n";
        for (int i = 0; i < n_banks; i++) {
            objectBanksCode += "    dw objectTypeBank" + i + ", {OBJECTTYPEBANK_" + i + "_PAGE}\n";
        }

        variables.put("OBJECT_TYPE_BANK_PTRS", objectBanksCode);
        return largest_size;
    }

    @Override
    public List<Pair<String, String>> getAsmPatternsToInstantiate() {
        List<Pair<String, String>> patterns = new ArrayList<>();
        patterns.add(new Pair<>("main-megarom.asm-pattern", "/src/main-autogenerated.asm"));
        patterns.add(new Pair<>("rules.asm-pattern", "/src/rules-autogenerated.asm"));
        patterns.add(new Pair<>("sound.asm-pattern", "/src/sound-autogenerated.asm"));
        patterns.add(new Pair<>("gfx.asm-pattern", "/src/gfx-autogenerated.asm"));
        return patterns;
    }

    @Override
    public void MemoryAllocation(String outputFolder, HashMap<String, String> assemblerVariables, PAKGame game) throws Exception {
        int page_size = 16 * 1024;
        List<SpaceAllocator.Block> blocksToAllocate = new ArrayList<>();
        pageSpaces = new ArrayList<>();
        for (int i = 0; i < max_pages; i++) {
            if (i == 0) {
                // no space in the first page (it's all for code)
                pageSpaces.add(new SpaceAllocator.Space("", "", config.spaceForDataInPage0, "" + i));
            } else {
                pageSpaces.add(new SpaceAllocator.Space("", "", page_size, "" + i));
            }
        }

        // Text banks:
        int textDataSize = game.textBankSizes.size() * 2;  // pointers
        for (int s : game.textBankSizes) {
            textDataSize += s;
        }
        blocksToAllocate.add(new SpaceAllocator.Block("text data", assemblerVariables.get("TEXT_BANKS"), "", textDataSize, "TEXT_MEGAROM_PAGE"));

        // Tile banks:
        int tileDataSize = game.tileBankSizes.size() * 2;  // pointers
        for (int s : game.tileBankSizes) {
            tileDataSize += s;
        }
        String tileContent = assemblerVariables.get("TILE_BANKS");
        if (game.bankSets.size() > 1) {
            tileContent += "\n\n" + assemblerVariables.get("TILE_BANKSETS");
        }
        blocksToAllocate.add(new SpaceAllocator.Block("tile data", tileContent, "", tileDataSize, "TILES_MEGAROM_PAGE"));

        // Object type banks:
        blocksToAllocate.add(new SpaceAllocator.Block("object type bank ptrs", assemblerVariables.get("OBJECT_TYPE_BANK_PTRS"), "", game.objectTypeBankSizes.size() * 4, "OBJECT_TYPE_BANK_PTRS_PAGE"));
        for (int i = 0; i < game.objectTypeBankSizes.size(); i++) {
            String objectBankCode = "objectTypeBank" + i + ":\n";
            objectBankCode += "    incbin \"data/objectTypeBank" + i + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
            blocksToAllocate.add(new SpaceAllocator.Block("object type bank " + i, objectBankCode, "", game.objectTypeBankSizes.get(i), "OBJECTTYPEBANK_" + i + "_PAGE"));
        }

        // Room banks:
        String roomBankPointersCode = "roomBankPointers:\n";
        for (int i = 0; i < game.roomBankSizes.size(); i++) {
            roomBankPointersCode += "    dw roomBank" + i + ", {ROOMBANK_" + i + "_PAGE}\n";
        }
        blocksToAllocate.add(new SpaceAllocator.Block("room bank ptrs", roomBankPointersCode, "", game.roomBankSizes.size() * 4, "ROOMBANK_PTRS_PAGE"));
        for (int i = 0; i < game.roomBankSizes.size(); i++) {
            String objectBankCode = "roomBank" + i + ":\n";
            objectBankCode += "    incbin \"data/rooms/roomBank" + i + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
            blocksToAllocate.add(new SpaceAllocator.Block("room bank " + i, objectBankCode, "", game.roomBankSizes.get(i), "ROOMBANK_" + i + "_PAGE"));
        }

        // Dialogues:
        int dialogueDataSize = game.dialogues.size() * 2;
        for (int i = 0; i < game.dialogues.size(); i++) {
            File f = new File(outputFolder + "data/dialogue" + i + ".bin");
            dialogueDataSize += f.length();
        }
        blocksToAllocate.add(new SpaceAllocator.Block("dialogue data", assemblerVariables.get("DIALOGUE_DATA"), "", dialogueDataSize, "DIALOGUE_DATA_PAGE"));

        // Gui:
        blocksToAllocate.add(new SpaceAllocator.Block("gui data", assemblerVariables.get("GUI_DATA"), "", game.gui_compressed_size, "GUI_DATA_PAGE"));

        // Items:
        String itemCode = "item_sprite_data:\n"
                + "    incbin \"data/items.{COMPRESSOR_EXTENSION}\"\n\n"
                + "item_text_data:\n"
                + "{ITEM_TEXT_DATA}\n\n";
        int itemCodeSize = (int) (new File(outputFolder + "data/items." + PAKETConfig.compressorExtension[config.compressor]).length()) + game.itemIDs.size() * 6;
        blocksToAllocate.add(new SpaceAllocator.Block("item data", itemCode, "", itemCodeSize, "ITEM_DATA_PAGE"));

        // Pointers:
        String pointersCode = "pointers_compressed:\n"
                + "    incbin \"data/pointers.{COMPRESSOR_EXTENSION}\"\n\n";
        int pointersSize = (int) (new File(outputFolder + "data/pointers." + PAKETConfig.compressorExtension[config.compressor]).length());
        blocksToAllocate.add(new SpaceAllocator.Block("pointers data", pointersCode, "", pointersSize, "POINTERS_DATA_PAGE"));

        // Font:
        String fontCode = "font:\n"
                + "    incbin \"data/font.bin\"\n\n";
        int fontSize = (int) (new File(outputFolder + "data/font.bin")).length();
        blocksToAllocate.add(new SpaceAllocator.Block("font data", fontCode, "", fontSize, "FONT_DATA_PAGE"));

        // Rules + Scripts:
        String rulesCode
                = "; global rules:\n"
                + "global_rules_item:\n"
                + "    incbin \"data/itemrules.bin\"\n"
                + "global_rules_on_room_load:\n"
                + "    incbin \"data/onroomloadrules.bin\"\n"
                + "global_rules_on_room_start:\n"
                + "    incbin \"data/onroomstartrules.bin\"\n\n"
                + "{SCRIPTS}\n\n";
        int rulesSize = 0;
        rulesSize += (int) (new File(outputFolder + "data/itemrules.bin")).length();
        rulesSize += (int) (new File(outputFolder + "data/onroomloadrules.bin")).length();
        rulesSize += (int) (new File(outputFolder + "data/onroomstartrules.bin")).length();
        rulesSize += game.scripts.size() * 2;  // pointers
        for (int i = 0; i < game.scripts.size(); i++) {
            List<Integer> scriptBytes = game.scripts.get(i).m_b.toBytesForAssembler(game.textIDHash, game, game.dialogues, false, false, this);
            rulesSize += scriptBytes.size();
        }
        blocksToAllocate.add(new SpaceAllocator.Block("rules/scripts data", rulesCode, "", rulesSize, "RULES_AND_SCRIPTS_DATA_PAGE"));

        // SFX/Music:
        blocksToAllocate.add(new SpaceAllocator.Block("sfx data", assemblerVariables.get("SFX_DATA"), "", game.sfx_data_size, "SFX_DATA_PAGE"));
        blocksToAllocate.add(new SpaceAllocator.Block("music data", assemblerVariables.get("SONG_DATA"), "", game.song_data_size, "SONG_DATA_PAGE"));

        // Cutscenes:
        if (assemblerVariables.get("SCRIPT_DRAW_CUTSCENE_IMAGE_USED").equals("1")) {
            String cutscenePointersCode = "cutscene_image_pointers:\n";
            for (int i = 0; i < game.cutsceneImages.size(); i++) {
                cutscenePointersCode += "    dw cutscene_" + game.cutsceneImages.get(i).assembler_name + ", {CUTSCENE_" + i + "_PAGE}\n";
            }
            blocksToAllocate.add(new SpaceAllocator.Block("cutscene ptrs", cutscenePointersCode, "", game.cutsceneImages.size() * 4, "CUTSCENE_PTRS_PAGE"));
            for (int i = 0; i < game.cutsceneImages.size(); i++) {
                String cutsceneCode = "cutscene_" + game.cutsceneImages.get(i).assembler_name + ":\n";
                cutsceneCode += "    incbin \"" + outputFolder + "/src/data/cutscenes/cutscene-" + game.cutsceneImages.get(i).assembler_name + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
                blocksToAllocate.add(new SpaceAllocator.Block("cutscene " + i, cutsceneCode, "", game.cutsceneSizes.get(i), "CUTSCENE_" + i + "_PAGE"));
            }
        }

        SpaceAllocator.allocateBlocksIntoPages(pageSpaces, blocksToAllocate, assemblerVariables, config);
        String dataPagesContent = "";
        for (int i = 0; i < pageSpaces.size(); i++) {
            if (i == 0) {
                assemblerVariables.put("PAGE0_DATA_CONTENT", pageSpaces.get(i).rawContent);
            } else {
                if (!pageSpaces.get(i).rawContent.isBlank()) {
                    dataPagesContent += "; ------------------------------------------------\n";
                    dataPagesContent += "    org #8000\n";
                    dataPagesContent += "start_of_page_" + i + ":\n\n";
                    dataPagesContent += pageSpaces.get(i).rawContent;
                    dataPagesContent += "end_of_page_" + i + ":\n";
                    dataPagesContent += "    ds #c000-$\n\n";
                }
            }
        }
        String pageNumbers = "";
        pageNumbers += "TEXT_MEGAROM_PAGE: equ " + assemblerVariables.get("TEXT_MEGAROM_PAGE") + "\n";
        pageNumbers += "TILES_MEGAROM_PAGE: equ " + assemblerVariables.get("TILES_MEGAROM_PAGE") + "\n";
        pageNumbers += "OBJECT_TYPE_BANK_PTRS_PAGE: equ " + assemblerVariables.get("OBJECT_TYPE_BANK_PTRS_PAGE") + "\n";
        pageNumbers += "ROOMBANK_PTRS_PAGE: equ " + assemblerVariables.get("ROOMBANK_PTRS_PAGE") + "\n";
        pageNumbers += "DIALOGUE_DATA_PAGE: equ " + assemblerVariables.get("DIALOGUE_DATA_PAGE") + "\n";
        pageNumbers += "GUI_DATA_PAGE: equ " + assemblerVariables.get("GUI_DATA_PAGE") + "\n";
        pageNumbers += "ITEM_DATA_PAGE: equ " + assemblerVariables.get("ITEM_DATA_PAGE") + "\n";
        pageNumbers += "POINTERS_DATA_PAGE: equ " + assemblerVariables.get("POINTERS_DATA_PAGE") + "\n";
        pageNumbers += "FONT_DATA_PAGE: equ " + assemblerVariables.get("FONT_DATA_PAGE") + "\n";
        pageNumbers += "RULES_AND_SCRIPTS_DATA_PAGE: equ " + assemblerVariables.get("RULES_AND_SCRIPTS_DATA_PAGE") + "\n";
        pageNumbers += "SFX_DATA_PAGE: equ " + assemblerVariables.get("SFX_DATA_PAGE") + "\n";
        pageNumbers += "SONG_DATA_PAGE: equ " + assemblerVariables.get("SONG_DATA_PAGE") + "\n";
        pageNumbers += "CUTSCENE_PTRS_PAGE: equ " + assemblerVariables.get("CUTSCENE_PTRS_PAGE") + "\n";
        assemblerVariables.put("DATA_PAGES_CONTENT", dataPagesContent);
        assemblerVariables.put("MEGAROM_PAGE_NUMBERS", pageNumbers);
    }

    @Override
    public void calculateUsedAndFreeSpace(String symbolFile) throws Exception {
        String endOfPage0Tag = "end_of_page_0";
        int start_of_page0 = 16 * 1024;
        int end_of_page0 = 0;
        int start_of_ram = 48 * 1024;
        int end_of_ram = 0;
        int max_usable_ram = 0xf380;
        int stack_size = 128;

        BufferedReader br = new BufferedReader(new FileReader(symbolFile));
        while (true) {
            String line = br.readLine();
            if (line == null) {
                break;
            }
            if (line.contains(END_OF_RAM_TAG)) {
                end_of_ram = getSymbolTableAddress(line);
            }
            if (line.contains(endOfPage0Tag)) {
                end_of_page0 = getSymbolTableAddress(line);
            }
        }

        int ram_free = ((max_usable_ram - stack_size) - end_of_ram);

        config.diggest("---- General Space Analysis ----");
        config.diggest("ROM page 0 used: " + (end_of_page0 - start_of_page0) + " / " + (16 * 1024));
        int freeSpaceInCodePage = 16 * 1024 - (end_of_page0 - start_of_page0);
        int freeSpaceInUsedPages = freeSpaceInCodePage;
        int usedPages = 1;
        for (int i = 1; i < pageSpaces.size(); i++) {
            if (pageSpaces.get(i).spaceLeft != 16 * 1024) {
                config.diggest("ROM page " + i + " used: " + (16 * 1024 - pageSpaces.get(i).spaceLeft) + " / " + +(16 * 1024));
                freeSpaceInUsedPages += pageSpaces.get(i).spaceLeft;
                usedPages += 1;
            }
        }
        config.diggest("ROM available (in used pages): " + freeSpaceInUsedPages);
        config.diggest("ROM could still contain " + (max_pages - usedPages) + " more pages.");
        config.diggest("Total RAM space used: " + (end_of_ram - start_of_ram));
        config.diggest("Total RAM space available: " + ram_free);
    }
    
    @Override
    public void generateBinary(PAKGame game, String destinationFolder) throws Exception {
        String binaryName = destinationFolder + File.separator + "pac-" + game.language;
        if (config.run_mdl_optimizers) {
            config.diggest("PAKETCompiler: compiling game (with MDL optimization)...");
            // We do not use the reorganizer in the MegaROM platform, in case it messes up the pages:
            PAKETCompiler.callMDL(new String[]{destinationFolder + "/src/main-autogenerated.asm", "-bin", binaryName + ".rom", "-st", binaryName + ".sym", "-st-constants", "-po", "-asm+:html", binaryName + ".html"}, config);
        } else {
            config.diggest("PAKETCompiler: compiling game...");
            PAKETCompiler.callMDL(new String[]{destinationFolder + "/src/main-autogenerated.asm", "-bin", binaryName + ".rom", "-st", binaryName + ".sym", "-st-constants",}, config);
        }

        calculateUsedAndFreeSpace(binaryName + ".sym");
    }
    
}
