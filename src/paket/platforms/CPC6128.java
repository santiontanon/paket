/*
 * author: Santiago Ontañón Villar (Brain Games)
 */
package paket.platforms;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import paket.compiler.PAKETCompiler;
import paket.compiler.PAKETConfig;
import paket.compiler.SpaceAllocator;
import paket.compiler.optimizers.PAKETOptimizer;
import paket.pak.PAKGame;
import paket.pak.PAKObjectType;
import paket.util.ConsoleExecution;
import paket.util.Pair;
import paket.util.Z80Assembler;
import paket.util.idsk.IDsk;

/**
 *
 * @author santi
 */
public class CPC6128 extends CPC {

    // Which byte do we need to output to #7f to select the desired data page:
    // Notice that "0" is set to also "#c0", since it's not even in the page we
    // are swapping (we swap the page in #4000 - #8000):
    // The values result in the following pages mapped to RAM:
    //    #c0: 0, 1, 2, 3
    //    #c4: 0, 4, 2, 3
    //    #c5: 0, 5, 2, 3
    //    #c6: 0, 6, 2, 3
    //    #c7: 0, 7, 2, 3
    // pages: 0, 1, 4, 5, 6, 7
    
    public final int SAVEGAME_SIZE = 128;  // it's way less than this, but just some safe buffer
    
    int stack_size = 128;
    int max_useable_ram = 0xc000 - stack_size;
    String[] dataPageOutByte = {"#c0", "#c0", "#c4", "#c5", "#c6", "#c7"};
    List<SpaceAllocator.Space> pageSpaces = null;

    public CPC6128(HashMap<String, String> a_variables, PAKETConfig a_config) {
        super(a_variables, a_config);
        
        supportedSaveGameModes.clear();
        supportedSaveGameModes.add("disk");
        defaultSaveGameMode = "disk";
        
    }

    @Override
    public void initPlatform(HashMap<String, String> assemblerVariables, PAKGame game) {
        assemblerVariables.put("IS_6128", "1");
        
        assemblerVariables.put("STACK_ADDRESS", "" + STACK_ADDRESS);
    }
    
    @Override
    public Pair<String[], String[]> saveGameCodeFileNames()
    {
        return new Pair<>(
                new String[]{"paketdsk.asm", "paketdsk-internal.asm"},
                 new String[]{"paketdsk-ram.asm"});
    }    
    
    @Override
    public void generateBinary(PAKGame game, String destinationFolder) throws Exception {
        String binaryName = destinationFolder + File.separator + "pac-" + game.language;
        String loaderName = destinationFolder + File.separator + "loader-" + game.language;
        if (config.run_mdl_optimizers) {
            config.diggest("PAKETCompiler: compiling game (with MDL optimization)...");
            // Do not use "-ro" since it might mess up the page layout:
            PAKETCompiler.callMDL(new String[]{destinationFolder + "/src/main-autogenerated.asm", "-bin", binaryName + ".bin", "-st", binaryName + ".sym", "-st-constants", "-po", "-cpu", "z80cpc", "-asm+:html", binaryName + ".html"}, config);
        } else {
            config.diggest("PAKETCompiler: compiling game...");
            PAKETCompiler.callMDL(new String[]{destinationFolder + "/src/main-autogenerated.asm", "-bin", binaryName + ".bin", "-st", binaryName + ".sym", "-st-constants",}, config);
        }
        FileInputStream fis = new FileInputStream(new File(binaryName + ".bin"));
        byte binary[] = fis.readAllBytes();
        config.info("    raw binary size: " + binary.length);

        // Split binary into pieces, one for each page:
        // Page 0: code
        {
            List<Integer> piece = new ArrayList<>();
            boolean nonZero = false;
            for (int i = 16 * 1024 - START_ADDRESS; i > 0; i--) {
                int v = binary[i - 1];
                if (v != 0) {
                    nonZero = true;
                }
                if (nonZero) {
                    piece.add(0, v);
                }
            }
            config.info("    page 0 piece (code) size: " + piece.size());
            FileOutputStream os = new FileOutputStream(binaryName + "-dsk-page0.bin");
            for (int v : piece) {
                os.write(v);
            }
            os.close();
        }

        // Data pages:
        int n_data_pages = 0;
        for (int page_start = 16 * 1024 - START_ADDRESS; page_start < binary.length; page_start += 16 * 1024) {
            List<Integer> piece = new ArrayList<>();
            boolean nonZero = false;
            for (int i = page_start + 16 * 1024; i > page_start; i--) {
                int v = binary[i - 1];
                if (v != 0) {
                    nonZero = true;
                }
                if (nonZero) {
                    piece.add(0, v);
                }
            }
            config.info("    page " + (n_data_pages + 1) + " piece (code) size: " + piece.size());
            FileOutputStream os = new FileOutputStream(binaryName + "-dsk-page" + (n_data_pages + 1) + ".bin");
            for (int v : piece) {
                os.write(v);
            }
            os.close();
            n_data_pages++;
        }

        // Generate the loader:
        config.info("PAKETCompiler: generating loader...");
        String DSK_LOADING_SCREEN_FILENAMES = "";
        String DSK_LOADING_SCREEN_CODE = "";
        if (LOADING_SCREEN_SIZES != null) {
            for (int i = 0; i < LOADING_SCREEN_SIZES.size(); i++) {
                DSK_LOADING_SCREEN_FILENAMES += "filename_img" + i + ":\n"
                        + "    db \"screen" + i + ".bin\"\n"
                        + "end_filename_img" + i + ":\n\n";

                DSK_LOADING_SCREEN_CODE += "    ld a, " + LOADING_SCREEN_MODES.get(i) + "\n"
                        + "    call scr_set_mode\n"
                        + "    ld hl, loader_palette_indexes_" + (i + 1) + "\n"
                        + "    call setup_colors_mode" + LOADING_SCREEN_MODES.get(i) + "\n"
                        + "    ld b, end_filename_img" + i + " - filename_img" + i + "\n"
                        + "    ld hl, filename_img" + i + "\n"
                        + "    call load_block\n"
                        + "    ld bc, 50*5*6  ; 5 second pause\n"
                        + "    call wait_bc_halts\n\n";

            }
        }

        variables.put("DSK_LOADING_SCREEN_FILENAMES", DSK_LOADING_SCREEN_FILENAMES);
        if (LOADING_SCREEN_SIZES != null) {
            variables.put("N_LOADING_SCREENS", "" + LOADING_SCREEN_SIZES.size());
        } else {
            variables.put("N_LOADING_SCREENS", "0");
        }
        variables.put("DSK_LOADING_SCREEN_CODE", DSK_LOADING_SCREEN_CODE);

        String DSK_LOADER_PALETTES_STRING = "";
        for (int i = 0; i < LOADING_SCREEN_DSK_PALETTE_INDEXES.size(); i++) {
            DSK_LOADER_PALETTES_STRING += "loader_palette_indexes_" + (i + 1) + ":\n    db " + LOADING_SCREEN_DSK_PALETTE_INDEXES.get(i) + "\n";
        }
        variables.put("DSK_LOADER_COLOR_PALETTES_INDEXES", DSK_LOADER_PALETTES_STRING);

        // Generate the page loading code:
        String DSK_LOADING_PAGES_CODE = "";
        String DSK_LOADING_PAGE_FILENAMES = "";
        for (int i = 0; i < n_data_pages + 1; i++) {
            DSK_LOADING_PAGES_CODE
                    += "    ld bc, #7f00\n"
                    + "    ld a, " + dataPageOutByte[i] + "\n"
                    + "    out (c), a\n"
                    + "    ld b, end_filename_page" + i + " - filename_page" + i + "\n"
                    + "    ld hl, filename_page" + i + "\n"
                    + "    call load_block\n\n";
            DSK_LOADING_PAGE_FILENAMES
                    += "filename_page" + i + ":\n"
                    + "    db \"data" + i + ".bin\"\n"
                    + "end_filename_page" + i + ":\n";
        }
        // Switch back to pages 0, 1, 2, 3:
        DSK_LOADING_PAGES_CODE
                += "    ld bc, #7f00\n"
                + "    ld a, " + dataPageOutByte[1] + "\n"
                + "    out (c), a\n";

        variables.put("DSK_LOADING_PAGES_CODE", DSK_LOADING_PAGES_CODE);
        variables.put("DSK_LOADING_PAGE_FILENAMES", DSK_LOADING_PAGE_FILENAMES);

        PAKETCompiler.instantiateAsmPatternFromResources("loader-dsk6128.asm-pattern", destinationFolder + "/src/loader-dsk-autogenerated.asm", variables, this);

        // Generate the DSK:
        PAKETCompiler.callMDL(new String[]{destinationFolder + "/src/loader-dsk-autogenerated.asm", "-bin", loaderName + "-dsk.bin", "-st", loaderName + "-dsk.sym"}, config);
        int dsk_loader_size = (int) (new File(loaderName + "-dsk.bin").length());
        config.info("    DSK loader size: " + dsk_loader_size);
        ConsoleExecution.execute(new String[]{"mv", loaderName + "-dsk.bin", destinationFolder + "/pac.bin"}, config);
        IDsk.main(new String[]{binaryName + ".dsk", "-n", "-i", destinationFolder + "/pac.bin", "-e", "a400", "-c", "a400", "-t", "1"}, config);
        ConsoleExecution.execute(new String[]{"mv", destinationFolder + "/pac.bin", loaderName + "-dsk.bin"}, config);

        if (LOADING_SCREEN_SIZES != null) {
            for (int i = 0; i < LOADING_SCREEN_SIZES.size(); i++) {
                IDsk.main(new String[]{binaryName + ".dsk", "-i", destinationFolder + "/src/data/screen" + i + ".bin", "-c", Z80Assembler.toHex16bit(LOADING_SCREEN_START_ADDRESSES.get(i), false), "-t", "1"}, config);
                IDsk.main(new String[]{binaryName + ".dsk", "-i", destinationFolder + "/src/data/screen" + i + ".bin", "-c", Z80Assembler.toHex16bit(LOADING_SCREEN_START_ADDRESSES.get(i), false), "-t", "1"}, config);
            }
        }
        for (int i = 0; i < n_data_pages + 1; i++) {
            String address = "40";
            if (i != 0) {
                address = "4000";
            }
            ConsoleExecution.execute(new String[]{"cp", binaryName + "-dsk-page" + i + ".bin", destinationFolder + "/data" + i + ".bin"}, config);
            IDsk.main(new String[]{binaryName + ".dsk", "-i", destinationFolder + "/data" + i + ".bin", "-c", address, "-t", "1"}, config);
            ConsoleExecution.execute(new String[]{"mv", destinationFolder + "/data" + i + ".bin", binaryName + "-dsk-page" + i + ".bin"}, config);
        }

        calculateUsedAndFreeSpace(binaryName + ".bin", binaryName + ".sym", this, game);
    }

    @Override
    public int generateObjectTypeBanks(String outputFolder, List<PAKObjectType> objectTypes, PAKGame game,
            PAKETOptimizer optimizerState) throws Exception {
        Pair<Integer, Integer> tmp = generateObjectTypeBanksInternal(outputFolder, objectTypes, game, optimizerState);
        int n_banks = tmp.m_a;
        int largest_size = tmp.m_b;

        String objectBanksCode = "objectTypeBanksPointers:\n";
        for (int i = 0; i < n_banks; i++) {
            objectBanksCode += "    dw objectTypeBank" + i + ", {OBJECTTYPEBANK_" + i + "_PAGE}\n";
        }
        objectBanksCode += "\n";
        for (int i = 0; i < n_banks; i++) {
            int size = (int) (new File(outputFolder + "data/objectTypeBank" + i + "." + PAKETConfig.compressorExtension[config.compressor]).length());
            objectTypeBanksTotalSize += size;
//            dataBanksToPotentiallyRelocateToVRAM.add(new SpaceAllocator.Block(
//                    "data:objectTypeBank" + i,
//                    "objectTypeBank" + i + ":\n ds virtual " + size + "\n",
//                    "objectTypeBank_" + i + "_temporary:\n    incbin \"data/objectTypeBank" + i + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n",
//                    size, null));
        }

        variables.put("OBJECT_TYPE_BANKS", objectBanksCode);
        return largest_size;
    }

    @Override
    public List<Pair<String, String>> getAsmPatternsToInstantiate() {
        List<Pair<String, String>> patterns = new ArrayList<>();
        patterns.add(new Pair<>("main6128.asm-pattern", "/src/main-autogenerated.asm"));
//        patterns.add(new Pair<>("rules.asm-pattern", "/src/rules-autogenerated.asm"));
//        patterns.add(new Pair<>("sound.asm-pattern", "/src/sound-autogenerated.asm"));
//        patterns.add(new Pair<>("gfx.asm-pattern", "/src/gfx-autogenerated.asm"));
        return patterns;
    }

    @Override
    public void MemoryAllocation(String outputFolder, HashMap<String, String> assemblerVariables, PAKGame game) throws Exception {
        int max_pages = 6;  // we will use 5 of the 8 RAM pages for data (+ 1 for code)
        int page_size = 16 * 1024;
        List<SpaceAllocator.Block> blocksToAllocate = new ArrayList<>();
        pageSpaces = new ArrayList<>();
        for (int i = 0; i < max_pages; i++) {
            if (i == 0) {
                // no space in the first page (it's all for code)
                pageSpaces.add(new SpaceAllocator.Space("", "", config.spaceForDataInPage0, dataPageOutByte[i]));
            } else {
                pageSpaces.add(new SpaceAllocator.Space("", "", page_size, dataPageOutByte[i]));
            }
        }
        
        // paketdsk:
        String paketdsk_include_code = 
            "IF {SCRIPT_SAVE_GAME_USED} + {SCRIPT_LOAD_GAME_USED} != 0\n" +
            "    include \"paketdsk-internal.asm\"\n" +
            "ENDIF\n";
        int paketdsk_size = 4096;  // it's less than this, but just to be safe
        blocksToAllocate.add(new SpaceAllocator.Block("paketdsk", paketdsk_include_code, "", paketdsk_size, "PAKETDSK_PAGE"));

        // Text banks:
        int textDataSize = game.textBankSizes.size() * 2;  // pointers
        for (int s : game.textBankSizes) {
            textDataSize += s;
        }
        blocksToAllocate.add(new SpaceAllocator.Block("text data", assemblerVariables.get("TEXT_BANKS"), "", textDataSize, "TEXT_PAGE"));

        // Tile banks:
        String tileContent = assemblerVariables.get("TILE_BANKS");
        if (game.bankSets.size() > 1) {
            tileContent += "\n\n" + assemblerVariables.get("TILE_BANKSETS");
        }
        tileContent += "\n\n" + assemblerVariables.get("TILE_BANKS_DATA");
        blocksToAllocate.add(new SpaceAllocator.Block("tile data", tileContent, "", game.tile_data_size, "TILES_PAGE"));

        // Object type banks:        
        blocksToAllocate.add(new SpaceAllocator.Block("object type bank ptrs", assemblerVariables.get("OBJECT_TYPE_BANKS"), "", game.objectTypeBankSizes.size() * 4, "OBJECT_TYPE_BANK_PTRS_PAGE"));
        for (int i = 0; i < game.objectTypeBankSizes.size(); i++) {
            String objectBankCode = "objectTypeBank" + i + ":\n";
            objectBankCode += "    incbin \"data/objectTypeBank" + i + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
            blocksToAllocate.add(new SpaceAllocator.Block("object type bank " + i, objectBankCode, "", game.objectTypeBankSizes.get(i), "OBJECTTYPEBANK_" + i + "_PAGE"));
        }

        // Room banks:
        String roomBankPointersCode = "roomBankPointers:\n";
        for (int i = 0; i < game.roomBankSizes.size(); i++) {
            roomBankPointersCode += "    dw roomBank" + i + ", {ROOMBANK_" + i + "_PAGE}\n";
        }
        blocksToAllocate.add(new SpaceAllocator.Block("room bank ptrs", roomBankPointersCode, "", game.roomBankSizes.size() * 4, "ROOMBANK_PTRS_PAGE"));
        for (int i = 0; i < game.roomBankSizes.size(); i++) {
            String objectBankCode = "roomBank" + i + ":\n";
            objectBankCode += "    incbin \"data/rooms/roomBank" + i + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
            blocksToAllocate.add(new SpaceAllocator.Block("room bank " + i, objectBankCode, "", game.roomBankSizes.get(i), "ROOMBANK_" + i + "_PAGE"));
        }

        // Dialogues:
        int dialogueDataSize = game.dialogues.size() * 2;
        for (int i = 0; i < game.dialogues.size(); i++) {
            File f = new File(outputFolder + "data/dialogue" + i + ".bin");
            int s = (int) f.length();
            dialogueDataSize += s;
        }
        blocksToAllocate.add(new SpaceAllocator.Block("dialogue data", assemblerVariables.get("DIALOGUE_DATA"), "", dialogueDataSize, "DIALOGUE_DATA_PAGE"));

        // Gui:
        blocksToAllocate.add(new SpaceAllocator.Block("gui data", assemblerVariables.get("GUI_DATA"), "", game.gui_compressed_size, "GUI_DATA_PAGE"));

        // Items:
        String itemCode = "item_sprite_data:\n"
                + "    incbin \"data/items.{COMPRESSOR_EXTENSION}\"\n\n";
        int itemCodeSize = (int) (new File(outputFolder + "data/items." + PAKETConfig.compressorExtension[config.compressor]).length()) + game.itemIDs.size() * 6;
        blocksToAllocate.add(new SpaceAllocator.Block("item data", itemCode, "", itemCodeSize, "ITEM_DATA_PAGE"));

        // Pointers:
        String pointersCode = "pointer_sprites:\n"
                + "    incbin \"data/pointers.bin\"\n\n";
        int pointersSize = (int) (new File(outputFolder + "data/pointers.bin").length());
        blocksToAllocate.add(new SpaceAllocator.Block("pointers data", pointersCode, "", pointersSize, "POINTERS_DATA_PAGE"));

        // Font:
        String fontCode = "font:\n"
                + "    incbin \"data/font.bin\"\n\n";
        int fontSize = (int) (new File(outputFolder + "data/font.bin")).length();
        blocksToAllocate.add(new SpaceAllocator.Block("font data", fontCode, "", fontSize, "FONT_DATA_PAGE"));

        // Rules + Scripts:
        String rulesCode
                = "; global rules:\n"
                + "global_rules_item:\n"
                + "    incbin \"data/itemrules.bin\"\n"
                + "global_rules_on_room_load:\n"
                + "    incbin \"data/onroomloadrules.bin\"\n"
                + "global_rules_on_room_start:\n"
                + "    incbin \"data/onroomstartrules.bin\"\n\n"
                + "{SCRIPTS}\n\n";
        int rulesSize = 0;
        rulesSize += (int) (new File(outputFolder + "data/itemrules.bin")).length();
        rulesSize += (int) (new File(outputFolder + "data/onroomloadrules.bin")).length();
        rulesSize += (int) (new File(outputFolder + "data/onroomstartrules.bin")).length();
        rulesSize += game.scripts.size() * 2;  // pointers
        for (int i = 0; i < game.scripts.size(); i++) {
            List<Integer> scriptBytes = game.scripts.get(i).m_b.toBytesForAssembler(game.textIDHash, game, game.dialogues, false, false, this);
            rulesSize += scriptBytes.size();
        }
        blocksToAllocate.add(new SpaceAllocator.Block("rules/scripts data", rulesCode, "", rulesSize, "RULES_AND_SCRIPTS_DATA_PAGE"));

        // SFX/Music:
        blocksToAllocate.add(new SpaceAllocator.Block("sfx data", assemblerVariables.get("SFX_DATA"), "", game.sfx_data_size, "SFX_DATA_PAGE"));
        blocksToAllocate.add(new SpaceAllocator.Block("music data", assemblerVariables.get("SONG_DATA"), "", game.song_data_size, "SONG_DATA_PAGE"));

        // Cutscenes:
        if (assemblerVariables.get("SCRIPT_DRAW_CUTSCENE_IMAGE_USED").equals("1")) {
            String cutscenePointersCode = "cutscene_image_pointers:\n";
            for (int i = 0; i < game.cutsceneImages.size(); i++) {
                cutscenePointersCode += "    dw cutscene_" + game.cutsceneImages.get(i).assembler_name + ", {CUTSCENE_" + i + "_PAGE}\n";
            }
            blocksToAllocate.add(new SpaceAllocator.Block("cutscene ptrs", cutscenePointersCode, "", game.cutsceneImages.size() * 4, "CUTSCENE_PTRS_PAGE"));
            for (int i = 0; i < game.cutsceneImages.size(); i++) {
                String cutsceneCode = "cutscene_" + game.cutsceneImages.get(i).assembler_name + ":\n";
                cutsceneCode += "    incbin \"/data/cutscenes/cutscene-" + game.cutsceneImages.get(i).assembler_name + "." + PAKETConfig.compressorExtension[config.compressor] + "\"\n";
                blocksToAllocate.add(new SpaceAllocator.Block("cutscene " + i, cutsceneCode, "", game.cutsceneSizes.get(i), "CUTSCENE_" + i + "_PAGE"));
            }
        }

//        allocateBlocksInCPC6128RAMPages(blocksToAllocate, pageContent, assemblerVariables);
        SpaceAllocator.allocateBlocksIntoPages(pageSpaces, blocksToAllocate, assemblerVariables, config);
        String dataPagesContent = "";
        for (int i = 0; i < pageSpaces.size(); i++) {
            if (i == 0) {
                assemblerVariables.put("PAGE0_DATA_CONTENT", pageSpaces.get(i).rawContent);
            } else {
                if (!pageSpaces.get(i).rawContent.isBlank()) {
                    dataPagesContent += "; ------------------------------------------------\n";
                    dataPagesContent += "    org #4000\n";
                    dataPagesContent += "start_of_page_" + i + ":\n\n";
                    dataPagesContent += pageSpaces.get(i).rawContent;
                    dataPagesContent += "end_of_page_" + i + ":\n";
                    dataPagesContent += "    ds #8000 - $\n\n";
                }
            }
        }
        String pageNumbers = "";
        pageNumbers += "TEXT_PAGE: equ " + assemblerVariables.get("TEXT_PAGE") + "\n";
        pageNumbers += "TILES_PAGE: equ " + assemblerVariables.get("TILES_PAGE") + "\n";
        pageNumbers += "OBJECT_TYPE_BANK_PTRS_PAGE: equ " + assemblerVariables.get("OBJECT_TYPE_BANK_PTRS_PAGE") + "\n";
        pageNumbers += "ROOMBANK_PTRS_PAGE: equ " + assemblerVariables.get("ROOMBANK_PTRS_PAGE") + "\n";
        pageNumbers += "DIALOGUE_DATA_PAGE: equ " + assemblerVariables.get("DIALOGUE_DATA_PAGE") + "\n";
        pageNumbers += "GUI_DATA_PAGE: equ " + assemblerVariables.get("GUI_DATA_PAGE") + "\n";
        pageNumbers += "ITEM_DATA_PAGE: equ " + assemblerVariables.get("ITEM_DATA_PAGE") + "\n";
        pageNumbers += "POINTERS_DATA_PAGE: equ " + assemblerVariables.get("POINTERS_DATA_PAGE") + "\n";
        pageNumbers += "FONT_DATA_PAGE: equ " + assemblerVariables.get("FONT_DATA_PAGE") + "\n";
        pageNumbers += "RULES_AND_SCRIPTS_DATA_PAGE: equ " + assemblerVariables.get("RULES_AND_SCRIPTS_DATA_PAGE") + "\n";
        pageNumbers += "SFX_DATA_PAGE: equ " + assemblerVariables.get("SFX_DATA_PAGE") + "\n";
        pageNumbers += "SONG_DATA_PAGE: equ " + assemblerVariables.get("SONG_DATA_PAGE") + "\n";
        pageNumbers += "CUTSCENE_PTRS_PAGE: equ " + assemblerVariables.get("CUTSCENE_PTRS_PAGE") + "\n";
        pageNumbers += "PAKETDSK_PAGE: equ " + assemblerVariables.get("PAKETDSK_PAGE") + "\n";
        assemblerVariables.put("DATA_PAGES_CONTENT", dataPagesContent);
        assemblerVariables.put("RAM_PAGE_NUMBERS", pageNumbers);

        // Now allocate the variables space:
        spaces = getRAMSpaces();

        // Allocate the RAM blocks:
        List<SpaceAllocator.Block> blocks = getRAMBlocks(outputFolder, game);
        SpaceAllocator.RAMAllocation(assemblerVariables, spaces, blocks, game, config);

        generateRAMAllocationAssembler(assemblerVariables);
    }

    @Override
    public void calculateUsedAndFreeSpace(String binaryFile, String symbolFile, Platform platform, PAKGame game) throws Exception {
        String endOfPage0Tag = "end_of_page_0";
        int start_of_page0 = 0x40;
        int end_of_page0 = 0;
        int end_of_ram = 0;

        BufferedReader br = new BufferedReader(new FileReader(symbolFile));
        while (true) {
            String line = br.readLine();
            if (line == null) {
                break;
            }
            if (line.contains(END_OF_RAM_TAG)) {
                end_of_ram = getSymbolTableAddress(line);
            }
            if (line.contains(endOfPage0Tag)) {
                end_of_page0 = getSymbolTableAddress(line);
            }
        }
        
        if (end_of_ram > max_useable_ram) {
            throw new Exception("The game uses too much RAM. When having a game that can save games to disk, RAM can only grow up to address #b100, but it's grown to " + Z80Assembler.toHex16bit(end_of_ram, true));
        }

        int ram_free = (max_useable_ram - end_of_ram);

        config.diggest("---- General Space Analysis ----");
        config.diggest("RAM page 0 used: " + (end_of_page0 - start_of_page0) + " / " + (16 * 1024));
        int freeSpaceInUsedPages = 16 * 1024 - (end_of_page0 - start_of_page0);
        for (int i = 1; i < pageSpaces.size(); i++) {
            int pageN = i;
            if (i != 1) {
                pageN = i + 2;
            }
            if (pageSpaces.get(i).spaceLeft != 16 * 1024) {
                config.diggest("RAM page " + pageN + " used: " + (16 * 1024 - pageSpaces.get(i).spaceLeft) + " / " + +(16 * 1024));
                freeSpaceInUsedPages += pageSpaces.get(i).spaceLeft;
            } else {
                config.diggest("RAM page " + pageN + " used: 0 / " + +(16 * 1024));
                freeSpaceInUsedPages += pageSpaces.get(i).spaceLeft;
            }
        }

//        List<Integer> free_vram_list = new ArrayList<>();
        int free_vram_space = 0;
        int vram_used = 0;
        for (SpaceAllocator.Space space : spaces) {
            if (space.startStatement.contains("VRAM")) {
                free_vram_space += space.spaceLeft;
                vram_used += space.size - space.spaceLeft;
//                free_vram_list.add(space.spaceLeft);
            }
        }

        int free_space = freeSpaceInUsedPages + ram_free;
        config.diggest("RAM available: " + free_space);
        config.diggest("RAM available (page 2, used for engine buffers and variables): " + ram_free + " (ignoring stack, used up to " + Z80Assembler.toHex16bit(end_of_ram, true) + ")");
        config.diggest("VRAM available: " + free_vram_space + " (used " + vram_used + ")");
        config.diggest("Total RAM/VRAM available: " + (free_space + free_vram_space));
    }
}
