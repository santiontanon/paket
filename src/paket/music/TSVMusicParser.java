/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package paket.music;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.StringTokenizer;
import paket.compiler.PAKET;
import paket.compiler.PAKETCompiler;
import paket.compiler.PAKETConfig;
import paket.pak.PAKGame;
import paket.pak.PAKSFX;
import paket.util.Pair;

/**
 *
 * @author santi
 */
public class TSVMusicParser {
    public static String noteNames[][] = {{"do","c"}, 
                                          {"do#", "reb","c#","db"},
                                          {"re","d"},
                                          {"re#", "mib","d#","eb"},
                                          {"mi","e"},
                                          {"fa","f"},
                                          {"fa#", "solb","f#","gb"},
                                          {"sol","g"},
                                          {"sol#", "lab","g#","ab"},
                                          {"la","a"},
                                          {"la#", "sib","a#","bb"},
                                          {"si","b"}};
    public static String SQUARE_WAVE = "square_wave";
    
    
    // LinkedHashMap to ensure that square wave is the first instrument!
    public HashMap<String, TSVInstrument> instruments = new LinkedHashMap<>();
    public HashMap<String, PAKSFX> sfxs = new LinkedHashMap<>();
    public boolean useInstrumentSpeed = false;
    
    
    public TSVMusicParser()
    {
        TSVInstrument squareWave = new TSVInstrument();
        squareWave.volume.add(12);
        instruments.put(SQUARE_WAVE, squareWave);
    }
    
    
    public Pair<Integer, Integer> compileAssemblerSong(TSVSong song, String fileName, List<Integer> notesUsed, PAKGame game, PAKETConfig config) throws Exception
    {
        PrintStream w = new PrintStream(new File(fileName + ".asm"));
        song.convertToAssembler("song", notesUsed, "  include \"../../sound-constants-autogenerated.asm\"", w, this, game, config);
        w.flush();
        w.close();  

        PAKETCompiler.callMDL(new String[]{fileName + ".asm", "-bin", fileName + ".bin"}, config);
        int compressedSize = PAKET.compress(fileName + ".bin", fileName, config);        
        
        File f = new File(fileName + ".bin");
        int binarySize = (int)f.length();
        
        return new Pair<>(binarySize, compressedSize);
    }

    
    public TSVSong loadTSVMusic(String fileName, PAKETConfig config) throws Exception
    {
        // Init:
        String songPath = PAKET.getFilePath(fileName);
        TSVSong song = new TSVSong();
        
        String ch_instrument[] = {SQUARE_WAVE, 
                                  SQUARE_WAVE, 
                                  SQUARE_WAVE};
        TSVNote channelNotes[] = {null, null, null};
        
        BufferedReader br = new BufferedReader(new FileReader(fileName));
        // Read the header:
        boolean parseInstrumentSpeed = false;
        boolean songFound = false;
        boolean instrumentsFound = false;
        boolean sfxFound = false;
        while(br.ready()) {
            String line = br.readLine();
            String columns[] = line.split("\t");
            if (columns.length > 0) {
                if (columns[0].equals("song:")) {
                    songFound = true;
                    break;

                } else if (columns[0].equals("instruments:")) {
                    parseInstrumentSpeed = false;
                    instrumentsFound = true;
                    sfxFound = false;

                } else if (columns[0].equals("instruments-with-speed:")) {
                    parseInstrumentSpeed = true;
                    useInstrumentSpeed = true;
                    instrumentsFound = true;
                    sfxFound = false;

                } else if (columns[0].equals("sfx:")) {
                    instrumentsFound = false;
                    sfxFound = true;

                } else if (instrumentsFound && columns.length>=2 && !columns[0].isEmpty() && !columns[1].isEmpty()) {
                    // instrument found:
                    String instrumentName = columns[0].trim().toLowerCase();
                    String instrumentDefinition[];                    
                    TSVInstrument instrument = new TSVInstrument();
                    if (parseInstrumentSpeed) {
                        if (columns.length < 3) {
                            throw new Exception("Expected three tab-separated columns for each instrument after instruments-with-speed!");
                        }
                        instrument.speed = Integer.parseInt(columns[1]);
                        instrumentDefinition = columns[2].split(",");
                    } else {
                        instrumentDefinition = columns[1].split(",");
                    }
                    for(String str:instrumentDefinition) {
                        int v = Integer.parseInt(str);
                        if (v < 0) {
                            if ((-v) > instrument.volume.size()) {
                                throw new Exception("Instrument repeat larger than insturment lenth in " + instrumentName);
                            }
                            instrument.repeat = v;
                            break;
                        }
                        instrument.volume.add(v);
                    }
                    if (instruments.containsKey(instrumentName)) {
                        // Check that the definitions match:
                        if (!instruments.get(instrumentName).equals(instrument)) {
                            throw new Exception("instrument " + instrumentName + " redefined in song " + fileName + " in a different way than in a previously loaded song!");
                        }
                    }
                    instruments.put(instrumentName, instrument);
                    config.info("TSVMusic new instrument: " + instrumentName);

                } else if (sfxFound && columns.length >= 2 && !columns[0].isEmpty() && !columns[1].isEmpty()) {
                    // sfx found:
                    String sfxName = columns[0].trim().toLowerCase();
                    String sfxFileName = columns[1].trim();
                    if (sfxFileName.startsWith("\"")) {
                        sfxFileName = sfxFileName.substring(1, sfxFileName.length()-1);
                    }
                    int type;
                    if (sfxFileName.endsWith(".asm")) {
                        type = PAKSFX.RAW_PAK_ASSEMBLER;
                    } else if (sfxFileName.endsWith(".bin")) {
                        type = PAKSFX.RAW_PAK_BINARY;
                    } else if (sfxFileName.endsWith(".afx")) {
                        type = PAKSFX.AYFX;
                    } else {
                        throw new Exception("Unrecognized file termination for SFX: " + sfxFileName);
                    }
                    PAKSFX sfx = new PAKSFX("sfx_" + sfxName, songPath + File.separator + sfxFileName, type);
                    sfxs.put(sfxName, sfx);
                    config.info("TSVMusic new sfx: " + sfxName + " -> " + sfxFileName);
                }
            }
        }     
        if (!songFound) return null;
        
        // Read the song:
        while(br.ready()) {
            String line = br.readLine();
            String columns[] = line.split("\t");
            for(int channel = 0;channel<columns.length;channel++) {
                String commands[] = columns[channel].split(",");
                for(String command:commands) {
                    command = command.strip();
                    if (command.length() == 0) continue;
                    command = command.toLowerCase();
                    StringTokenizer tokenizer = new StringTokenizer(command, "():");
                    String commandName = tokenizer.nextToken();
                    if (instruments.containsKey(commandName)) {
                        ch_instrument[channel] = commandName;
                    } else {
                        switch(commandName) {
                            case "-":
                                {
                                    TSVNote note = new TSVNote(0);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;                            
                                }
                                break;
                            case "repeat":
                                {
                                    int parameter = Integer.parseInt(tokenizer.nextToken());
                                    TSVNote note = new TSVNote(TSVNote.START_REPEAT, parameter);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;                            
                                }
                                break;
                            case "endrepeat":
                                {
                                    TSVNote note = new TSVNote(TSVNote.END_REPEAT, 0);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;                            
                                }
                                break;
                            case "sfx":
                                {
                                    String sfx = tokenizer.nextToken();
                                    TSVNote note = new TSVNote(sfx, 0);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;
                                }
                                break;
                            case "playsong":
                                {
                                    String songName = tokenizer.nextToken();
                                    int tempo = Integer.parseInt(tokenizer.nextToken());
                                    TSVNote note = new TSVNote(songName, tempo);
                                    note.absoluteNote = TSVNote.PLAY_SONG;
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;
                                    song.subSongsPlayed.add(songName);
                                }
                                break;
                            case "volume":
                                {
                                    Integer volume = Integer.parseInt(tokenizer.nextToken());
                                    TSVNote note = new TSVNote(TSVNote.SET_VOLUME, volume);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;
                                }
                                break;
                            default:
                                // it's a note!
                                String noteStr = command.substring(0, command.length() - 1);
                                String octaveStr = command.substring(command.length() - 1);
                                int found = -1;
                                for(int idx = 0; idx<noteNames.length; idx++) {
                                    String noteGroup[] = noteNames[idx];
                                    for(String noteName:noteGroup) {
                                        if (noteStr.equals(noteName)) {
                                            found = idx;
                                            break;
                                        }
                                    }
                                    if (found != -1) break;
                                }
                                if (found != -1) {
                                    int octave = Integer.parseInt(octaveStr);
                                    TSVNote note = new TSVNote(octave, found, 15, 0, ch_instrument[channel]);
                                    song.channels[channel].add(note);
                                    channelNotes[channel] = note;
                                } else {
                                    throw new Exception("unrecognized command: " + command);
                                }
                                break;
                        }
                    }
                }
            }

            // advance time:
            for(int i = 0;i<3;i++) {
                TSVNote note = channelNotes[i];
                if (note == null) {
                    note = new TSVNote(0);
                    song.channels[i].add(note);
                    channelNotes[i] = note;
                }
                if (note.absoluteNote >= -2) {
                    // if it's a note:
                    note.duration++;
                }
            }
        }

        return song;
    }
}
